import { SanityStegaClient, StegaConfig } from "@sanity/client/stega";
import { StudioPathLike } from "@sanity/client/csm";
import { ClientPerspective, ContentSourceMap as ContentSourceMap$2, QueryParams as QueryParams$1, SanityClient } from "@sanity/client";
type AllKeys<T> = T extends any ? keyof T : never;
type Primitive = boolean | number | string;
type ReadonlyIfObject<Value> = Value extends undefined ? Value : Value extends ((...args: any) => any) ? Value : Value extends Primitive ? Value : Value extends object ? Readonly<Value> : Value;
/**
 * Store object.
 */
interface ReadableAtom<Value = any> {
  /**
   * Get store value.
   *
   * In contrast with {@link ReadableAtom#value} this value will be always
   * initialized even if store had no listeners.
   *
   * ```js
   * $store.get()
   * ```
   *
   * @returns Store value.
   */
  get(): Value;

  /**
   * Listeners count.
   */
  readonly lc: number;

  /**
   * Subscribe to store changes.
   *
   * In contrast with {@link Store#subscribe} it do not call listener
   * immediately.
   *
   * @param listener Callback with store value and old value.
   * @returns Function to remove listener.
   */
  listen(listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value>) => void): () => void;

  /**
   * Low-level method to notify listeners about changes in the store.
   *
   * Can cause unexpected behaviour when combined with frontend frameworks
   * that perform equality checks for values, such as React.
   */
  notify(oldValue?: ReadonlyIfObject<Value>): void;

  /**
   * Unbind all listeners.
   */
  off(): void;

  /**
   * Subscribe to store changes and call listener immediately.
   *
   * ```
   * import { $router } from '../store'
   *
   * $router.subscribe(page => {
   *   console.log(page)
   * })
   * ```
   *
   * @param listener Callback with store value and old value.
   * @returns Function to remove listener.
   */
  subscribe(listener: (value: ReadonlyIfObject<Value>, oldValue?: ReadonlyIfObject<Value>) => void): () => void;

  /**
   * Low-level method to read storeâ€™s value without calling `onStart`.
   *
   * Try to use only {@link ReadableAtom#get}.
   * Without subscribers, value can be undefined.
   */
  readonly value: undefined | Value;
}
/**
 * Store with a way to manually change the value.
 */
interface WritableAtom<Value = any> extends ReadableAtom<Value> {
  /**
   * Change store value.
   *
   * ```js
   * $router.set({ path: location.pathname, page: parse(location.pathname) })
   * ```
   *
   * @param newValue New store value.
   */
  set(newValue: Value): void;
}
type KeyofBase = keyof any;
type Get<T, K$1 extends KeyofBase> = Extract<T, { [K1 in K$1]: any }>[K$1];
type HasIndexSignature<T> = string extends keyof T ? true : false;
type ValueWithUndefinedForIndexSignatures<Value, Key$1 extends keyof Value> = HasIndexSignature<Value> extends true ? undefined | Value[Key$1] : Value[Key$1];
interface MapStore<Value extends object = any> extends WritableAtom<Value> {
  /**
   * Subscribe to store changes.
   *
   * In contrast with {@link Store#subscribe} it do not call listener
   * immediately.
   *
   * @param listener Callback with store value and old value.
   * @param changedKey Key that was changed. Will present only if `setKey`
   *                   has been used to change a store.
   * @returns Function to remove listener.
   */
  listen(listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value>, changedKey: AllKeys<Value>) => void): () => void;

  /**
   * Low-level method to notify listeners about changes in the store.
   *
   * Can cause unexpected behaviour when combined with frontend frameworks
   * that perform equality checks for values, such as React.
   */
  notify(oldValue?: ReadonlyIfObject<Value>, changedKey?: AllKeys<Value>): void;

  /**
   * Change store value.
   *
   * ```js
   * $settings.set({ theme: 'dark' })
   * ```
   *
   * Operation is atomic, subscribers will be notified once with the new value.
   * `changedKey` will be undefined
   *
   * @param newValue New store value.
   */
  set(newValue: Value): void;

  /**
   * Change key in store value.
   *
   * ```js
   * $settings.setKey('theme', 'dark')
   * ```
   *
   * To delete key set `undefined`.
   *
   * ```js
   * $settings.setKey('theme', undefined)
   * ```
   *
   * @param key The key name.
   * @param value New value.
   */
  setKey<Key$1 extends AllKeys<Value>>(key: Key$1, value: Get<Value, Key$1> | ValueWithUndefinedForIndexSignatures<Value, Key$1>): void;

  /**
   * Subscribe to store changes and call listener immediately.
   *
   * ```
   * import { $router } from '../store'
   *
   * $router.subscribe(page => {
   *   console.log(page)
   * })
   * ```
   *
   * @param listener Callback with store value and old value.
   * @param changedKey Key that was changed. Will present only
   *                   if `setKey` has been used to change a store.
   * @returns Function to remove listener.
   */
  subscribe(listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value> | undefined, changedKey: AllKeys<Value> | undefined) => void): () => void;
}
/** @public */
interface QueryStoreState<QueryResponseResult, QueryResponseError> {
  loading: boolean;
  error?: QueryResponseError;
  data?: QueryResponseResult;
  sourceMap?: ContentSourceMap$2;
  perspective?: ClientPerspective;
}
/**
 * Creates a encoded payload suitable for passing to a `data-sanity` attribute, which are used by `@sanity/visual-editing`
 * @public
 */
type EncodeDataAttribute<QueryResponseResult = unknown> = (result: QueryResponseResult, sourceMap: ContentSourceMap$2 | undefined, studioUrl: Exclude<StegaConfig['studioUrl'], undefined> | undefined, path: StudioPathLike) => string | undefined;
/** @public */
interface EnableLiveModeOptions {
  /**
   * @deprecated -- no longer needed
   */
  allowStudioOrigin?: 'same-origin' | `https://${string}` | `http://${string}` | string;
  /**
   * You may use any client that is an `instanceof SanityClient` or `instanceof SanityStegaClient`.
   * Required when `ssr: true`, optional otherwise.
   * @example `import {createClient} from '@sanity/client'`
   * @example `import {createClient} from '@sanity/client/stega'`
   * @example `import {createClient} from '@sanity/preview-kit/client'`
   * @example `import {createClient} from 'next-sanity'`
   */
  client?: SanityClient | SanityStegaClient;
  /**
   * Fires when a connection is established to a parent Studio window.
   */
  onConnect?: () => void;
  /**
   * Fires when a connection is established to a parent Studio window and then lost.
   */
  onDisconnect?: () => void;
  /**
   * Fires when the perspective changes in the Studio, allowing you to persist the change to a session cookie if needed
   */
  onPerspective?: (perspective: Exclude<ClientPerspective, 'raw'>) => void;
}
/** @public */
type EnableLiveMode = (options: EnableLiveModeOptions) => () => void;
/** @internal */
type SetFetcher = (fetcher: Fetcher) => () => void;
/** @internal */
interface Fetcher {
  hydrate: <QueryResponseResult, QueryResponseError>(query: string, params: QueryParams$1, initial?: Pick<QueryStoreState<QueryResponseResult, QueryResponseError>, 'data' | 'sourceMap' | 'perspective'>) => QueryStoreState<QueryResponseResult, QueryResponseError>;
  fetch: <QueryResponseResult, QueryResponseError>(query: string, params: QueryParams$1, $fetch: MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>>, controller: AbortController) => void;
}
export { Fetcher as a, SetFetcher as c, EncodeDataAttribute as i, MapStore as l, EnableLiveMode as n, QueryParams$1 as o, EnableLiveModeOptions as r, QueryStoreState as s, ContentSourceMap$2 as t, WritableAtom as u };
//# sourceMappingURL=types.d.cts.map