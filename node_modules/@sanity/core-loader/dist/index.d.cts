import { a as Fetcher, c as SetFetcher, i as EncodeDataAttribute, l as MapStore, n as EnableLiveMode, o as QueryParams, r as EnableLiveModeOptions, s as QueryStoreState, t as ContentSourceMap, u as WritableAtom } from "./_chunks-dts/types.cjs";
import { SanityStegaClient } from "@sanity/client/stega";
import { ClientPerspective, ContentSourceMap as ContentSourceMap$1, QueryParams as QueryParams$1, SanityClient } from "@sanity/client";
import { Redis } from "ioredis";
type StorageOptionsType = "redis" | "memory";
type StorageOptions = {
  type: StorageOptionsType;
  options: StorageRedisOptions | StorageMemoryOptions;
};
type References = string | string[];
interface LoggerInput {
  msg: string;
  [key: string]: any;
}
interface Logger {
  debug: (input: LoggerInput) => void;
  warn: (input: LoggerInput) => void;
  error: (input: LoggerInput) => void;
}
interface StorageRedisOptions {
  client: Redis;
  log?: Logger;
  invalidation?: {
    referencesTTL: number;
  } | boolean;
}
interface StorageMemoryOptions {
  size?: number;
  log?: Logger;
  invalidation?: boolean;
}
interface DataTransformer {
  serialize: (data: any) => any;
  deserialize: (data: any) => any;
}
type Events = {
  onDedupe?: (key: string) => void;
  onError?: (err: any) => void;
  onHit?: (key: string) => void;
  onMiss?: (key: string) => void;
};
declare class StorageInterface {
  constructor(options: any);
  get(key: string): Promise<undefined | any>;
  set(key: string, value: any, ttl: number, references?: References): Promise<void>;
  remove(key: string): Promise<void>;
  invalidate(references: References): Promise<void>;
  clear(name: string): Promise<void>;
  refresh(): Promise<void>;
}
declare class Cache {
  constructor(options: {
    ttl: number | ((result: unknown) => number);
    stale?: number | ((result: unknown) => number);
    storage: StorageInterface;
  } & Events);
  define<T extends (args: any) => any, N extends string, S extends this>(name: N, opts: {
    storage?: StorageOptions;
    transformer?: DataTransformer;
    ttl?: number | ((result: Awaited<ReturnType<T>>) => number);
    stale?: number | ((result: Awaited<ReturnType<T>>) => number);
    serialize?: (...args: any[]) => any;
    references?: (args: Parameters<T>[0], key: string, result: Awaited<ReturnType<T>>) => References | Promise<References>;
  } & Events, func?: T): S & { [n in N]: T };
  define<T extends (args: any) => any, N extends string, S extends this>(name: N, opts: T): S & { [n in N]: T };
  clear(): Promise<void>;
  clear(name: string): Promise<void>;
  clear(name: string, value: any): Promise<void>;
  get(name: string, key: string): Promise<any>;
  set(name: string, key: string, value: any, ttl: number, references?: References): Promise<void>;
  invalidate(name: string, references: References): Promise<void>;
  invalidateAll(references: References, storage?: StorageOptionsType): Promise<void>;
}
/** @internal */
declare const runtime: string;
/** @public */
interface CreateQueryStoreOptions {
  /**
   * The Sanity client to use for fetching data, or `false` if `ssr: true` and it's set with `setServerClient` later
   * You may use any client that is an `instanceof SanityClient` or `instanceof SanityStegaClient`.
   * @example `import {createClient} from '@sanity/client'`
   * @example `import {createClient} from '@sanity/client/stega'`
   * @example `import {createClient} from '@sanity/preview-kit/client'`
   * @example `import {createClient} from 'next-sanity'`
   */
  client: SanityClient | SanityStegaClient | false;
  /**
   * If you want all data fetching to be done server-side in production, set this to `true` and `client: false`.
   * Then, in your server entry file, you can set the Sanity client with `setServerClient`.
   */
  ssr?: boolean;
  /** @internal */
  tag?: string;
}
/** @public */
interface QueryStore {
  createFetcherStore: <QueryResponseResult = unknown, QueryResponseError = unknown>(query: string, params?: QueryParams$1,
  /**
   * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`
   * and an optional speed optimization if `ssr: false`
   */
  initial?: {
    data: QueryResponseResult;
    sourceMap?: ContentSourceMap$1;
    perspective?: ClientPerspective;
  }) => MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>>;
  /**
   * When `ssr: true` you call this in your server entry point that imports the result of `createQueryStore` instance.
   * It's required to call it before any data fetching is done.
   */
  setServerClient: (client: SanityClient | SanityStegaClient) => void;
  enableLiveMode: EnableLiveMode;
  /** @internal */
  unstable__cache: {
    instance: Cache & {
      fetch: <QueryResponseResult>(key: string) => Promise<{
        result: QueryResponseResult;
        resultSourceMap: ContentSourceMap$1 | undefined;
      }>;
    };
  };
  /** @internal */
  unstable__serverClient: {
    /**
     * Only set if `ssr: true` and `setServerClient` has been called.
     */
    instance: SanityClient | undefined;
    /**
     * Will be `true` if the client given to `setServerClient` has a token configured.
     */
    canPreviewDrafts?: boolean;
  };
}
/** @public */
declare const createQueryStore: (options: CreateQueryStoreOptions) => QueryStore;
export { ContentSourceMap, CreateQueryStoreOptions, EnableLiveMode, EnableLiveModeOptions, EncodeDataAttribute, Fetcher, type MapStore, QueryParams, QueryStore, QueryStoreState, SetFetcher, type WritableAtom, createQueryStore, runtime };
//# sourceMappingURL=index.d.cts.map