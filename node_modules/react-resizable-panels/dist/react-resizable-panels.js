"use client";
import { jsx as W } from "react/jsx-runtime";
import { useId as $e, useLayoutEffect as Ne, useEffect as _e, useRef as T, useCallback as xe, createContext as Fe, useImperativeHandle as ze, useState as G, useMemo as be, useSyncExternalStore as He, useContext as We } from "react";
function z(e, t = "Assertion error") {
  if (!e)
    throw Error(t);
}
function re(e, t) {
  return t.sort(
    e === "horizontal" ? je : Be
  );
}
function je(e, t) {
  const n = e.element.offsetLeft - t.element.offsetLeft;
  return n !== 0 ? n : e.element.offsetWidth - t.element.offsetWidth;
}
function Be(e, t) {
  const n = e.element.offsetTop - t.element.offsetTop;
  return n !== 0 ? n : e.element.offsetHeight - t.element.offsetHeight;
}
function te({
  group: e
}) {
  const { orientation: t, panels: n } = e;
  return n.reduce((o, r) => (o += t === "horizontal" ? r.element.offsetWidth : r.element.offsetHeight, o), 0);
}
function we(e) {
  const { element: t, orientation: n, panels: o, separators: r } = e, s = re(
    n,
    Array.from(t.children).filter((l) => l instanceof HTMLElement).map((l) => ({ element: l }))
  ).map(({ element: l }) => l), c = [];
  let i, a;
  for (const l of s) {
    const f = o.find(
      (u) => u.element === l
    );
    if (f) {
      if (i) {
        const u = i.element.getBoundingClientRect(), m = l.getBoundingClientRect();
        c.push({
          group: e,
          groupSize: te({ group: e }),
          panels: [i, f],
          separator: a,
          rect: n === "horizontal" ? new DOMRect(
            u.right,
            m.top,
            m.left - u.right,
            m.height
          ) : new DOMRect(
            m.left,
            u.bottom,
            m.width,
            m.top - u.bottom
          )
        });
      }
      i = f, a = void 0;
    } else {
      const u = r.find(
        (m) => m.element === l
      );
      u ? a = u : (i = void 0, a = void 0);
    }
  }
  return c;
}
function Ue(e, t) {
  const n = getComputedStyle(e), o = parseFloat(n.fontSize);
  return t * o;
}
function Ke(e, t) {
  const n = getComputedStyle(e.ownerDocument.body), o = parseFloat(n.fontSize);
  return t * o;
}
function Ve(e) {
  return e / 100 * window.innerHeight;
}
function Xe(e) {
  return e / 100 * window.innerWidth;
}
function Ye(e) {
  switch (typeof e) {
    case "number":
      return [e, "px"];
    case "string": {
      const t = parseFloat(e);
      return e.endsWith("%") ? [t, "%"] : e.endsWith("px") ? [t, "px"] : e.endsWith("rem") ? [t, "rem"] : e.endsWith("em") ? [t, "em"] : e.endsWith("vh") ? [t, "vh"] : e.endsWith("vw") ? [t, "vw"] : [t, "%"];
    }
  }
}
function J({
  groupSize: e,
  panelElement: t,
  styleProp: n
}) {
  let o;
  const [r, s] = Ye(n);
  switch (s) {
    case "%": {
      o = r / 100 * e;
      break;
    }
    case "px": {
      o = r;
      break;
    }
    case "rem": {
      o = Ke(t, r);
      break;
    }
    case "em": {
      o = Ue(t, r);
      break;
    }
    case "vh": {
      o = Ve(r);
      break;
    }
    case "vw": {
      o = Xe(r);
      break;
    }
  }
  return o;
}
function I(e) {
  return parseFloat(e.toFixed(3));
}
function pe(e) {
  const { panels: t } = e, n = te({ group: e });
  return t.map((o) => {
    const { element: r, panelConstraints: s } = o;
    let c = 0;
    if (s.collapsedSize) {
      const f = J({
        groupSize: n,
        panelElement: r,
        styleProp: s.collapsedSize
      });
      c = I(f / n * 100);
    }
    let i;
    if (s.defaultSize) {
      const f = J({
        groupSize: n,
        panelElement: r,
        styleProp: s.defaultSize
      });
      i = I(f / n * 100);
    }
    let a = 0;
    if (s.minSize) {
      const f = J({
        groupSize: n,
        panelElement: r,
        styleProp: s.minSize
      });
      a = I(f / n * 100);
    }
    let l = 100;
    if (s.maxSize) {
      const f = J({
        groupSize: n,
        panelElement: r,
        styleProp: s.maxSize
      });
      l = I(f / n * 100);
    }
    return {
      collapsedSize: c,
      collapsible: s.collapsible === !0,
      defaultSize: i,
      minSize: a,
      maxSize: l,
      panelId: o.id
    };
  });
}
class qe {
  #e = {};
  addListener(t, n) {
    const o = this.#e[t];
    return o === void 0 ? this.#e[t] = [n] : o.includes(n) || o.push(n), () => {
      this.removeListener(t, n);
    };
  }
  emit(t, n) {
    const o = this.#e[t];
    if (o !== void 0)
      if (o.length === 1)
        o[0].call(null, n);
      else {
        let r = !1, s = null;
        const c = Array.from(o);
        for (let i = 0; i < c.length; i++) {
          const a = c[i];
          try {
            a.call(null, n);
          } catch (l) {
            s === null && (r = !0, s = l);
          }
        }
        if (r)
          throw s;
      }
  }
  removeAllListeners() {
    this.#e = {};
  }
  removeListener(t, n) {
    const o = this.#e[t];
    if (o !== void 0) {
      const r = o.indexOf(n);
      r >= 0 && o.splice(r, 1);
    }
  }
}
function w(e, t, n = 0) {
  return Math.abs(I(e) - I(t)) <= n;
}
let R = {
  cursorFlags: 0,
  interactionState: {
    state: "inactive"
  },
  mountedGroups: /* @__PURE__ */ new Map()
};
const A = new qe();
function O() {
  return R;
}
function C(e) {
  const t = typeof e == "function" ? e(R) : e;
  if (R === t)
    return R;
  const n = R;
  return R = {
    ...R,
    ...t
  }, t.cursorFlags !== void 0 && A.emit("cursorFlagsChange", R.cursorFlags), t.interactionState !== void 0 && A.emit("interactionStateChange", R.interactionState), t.mountedGroups !== void 0 && (R.mountedGroups.forEach((o, r) => {
    o.derivedPanelConstraints.forEach((s) => {
      if (s.collapsible) {
        const { layout: c } = n.mountedGroups.get(r) ?? {};
        if (c) {
          const i = w(
            s.collapsedSize,
            o.layout[s.panelId]
          ), a = w(
            s.collapsedSize,
            c[s.panelId]
          );
          i && !a && (r.inMemoryLastExpandedPanelSizes[s.panelId] = c[s.panelId]);
        }
      }
    });
  }), A.emit("mountedGroupsChange", R.mountedGroups)), R;
}
const Ze = (e) => e, ie = () => {
}, Le = 1, Pe = 2, Ee = 4, Re = 8, me = {
  coarse: 10,
  precise: 5
};
function Je({
  cursorFlags: e,
  groups: t,
  state: n
}) {
  let o = 0, r = 0;
  switch (n) {
    case "active":
    case "hover":
      t.forEach((s) => {
        if (!s.disableCursor)
          switch (s.orientation) {
            case "horizontal": {
              o++;
              break;
            }
            case "vertical": {
              r++;
              break;
            }
          }
      });
  }
  if (o === 0 && r === 0)
    return null;
  switch (n) {
    case "active": {
      const s = (e & Le) !== 0, c = (e & Pe) !== 0, i = (e & Ee) !== 0, a = (e & Re) !== 0;
      if (e) {
        if (s)
          return i ? "se-resize" : a ? "ne-resize" : "e-resize";
        if (c)
          return i ? "sw-resize" : a ? "nw-resize" : "w-resize";
        if (i)
          return "s-resize";
        if (a)
          return "n-resize";
      }
      break;
    }
  }
  return o > 0 && r > 0 ? "move" : o > 0 ? "ew-resize" : "ns-resize";
}
let se, k;
function le() {
  k === void 0 && (k = new CSSStyleSheet(), document.adoptedStyleSheets = [k]);
  const { cursorFlags: e, interactionState: t } = O();
  switch (t.state) {
    case "active":
    case "hover": {
      const n = Je({
        cursorFlags: e,
        groups: t.hitRegions.map((r) => r.group),
        state: t.state
      }), o = `*{cursor: ${n} !important; ${t.state === "active" ? "touch-action: none;" : ""} }`;
      if (se === o)
        return;
      se = o, n ? k.cssRules.length === 0 ? k.insertRule(o) : k.replaceSync(o) : k.cssRules.length === 1 && k.deleteRule(0);
      break;
    }
    case "inactive": {
      se = void 0, k.cssRules.length === 1 && k.deleteRule(0);
      break;
    }
  }
}
function Qe(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function j(e, t) {
  return w(e, t) ? 0 : e > t ? 1 : -1;
}
function F({
  panelConstraints: e,
  size: t
}) {
  const {
    collapsedSize: n = 0,
    collapsible: o,
    maxSize: r = 100,
    minSize: s = 0
  } = e;
  if (j(t, s) < 0)
    if (o) {
      const c = (n + s) / 2;
      j(t, c) < 0 ? t = n : t = s;
    } else
      t = s;
  return t = Math.min(r, t), t = I(t), t;
}
function B({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: o,
  prevLayout: r,
  trigger: s
}) {
  if (w(e, 0))
    return t;
  const c = Object.values(t), i = Object.values(r), a = [...c], [l, f] = o;
  z(l != null, "Invalid first pivot index"), z(f != null, "Invalid second pivot index");
  let u = 0;
  if (s === "keyboard") {
    {
      const d = e < 0 ? f : l, p = n[d];
      z(
        p,
        `Panel constraints not found for index ${d}`
      );
      const {
        collapsedSize: h = 0,
        collapsible: v,
        minSize: x = 0
      } = p;
      if (v) {
        const S = c[d];
        if (z(
          S != null,
          `Previous layout not found for panel index ${d}`
        ), w(S, h)) {
          const y = x - S;
          j(y, Math.abs(e)) > 0 && (e = e < 0 ? 0 - y : y);
        }
      }
    }
    {
      const d = e < 0 ? l : f, p = n[d];
      z(
        p,
        `No panel constraints found for index ${d}`
      );
      const {
        collapsedSize: h = 0,
        collapsible: v,
        minSize: x = 0
      } = p;
      if (v) {
        const S = c[d];
        if (z(
          S != null,
          `Previous layout not found for panel index ${d}`
        ), w(S, x)) {
          const y = S - h;
          j(y, Math.abs(e)) > 0 && (e = e < 0 ? 0 - y : y);
        }
      }
    }
  }
  {
    const d = e < 0 ? 1 : -1;
    let p = e < 0 ? f : l, h = 0;
    for (; ; ) {
      const x = c[p];
      z(
        x != null,
        `Previous layout not found for panel index ${p}`
      );
      const y = F({
        panelConstraints: n[p],
        size: 100
      }) - x;
      if (h += y, p += d, p < 0 || p >= n.length)
        break;
    }
    const v = Math.min(Math.abs(e), Math.abs(h));
    e = e < 0 ? 0 - v : v;
  }
  {
    let p = e < 0 ? l : f;
    for (; p >= 0 && p < n.length; ) {
      const h = Math.abs(e) - Math.abs(u), v = c[p];
      z(
        v != null,
        `Previous layout not found for panel index ${p}`
      );
      const x = v - h, S = F({
        panelConstraints: n[p],
        size: x
      });
      if (!w(v, S) && (u += v - S, a[p] = S, u.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? p-- : p++;
    }
  }
  if (Qe(i, a))
    return r;
  {
    const d = e < 0 ? f : l, p = c[d];
    z(
      p != null,
      `Previous layout not found for panel index ${d}`
    );
    const h = p + u, v = F({
      panelConstraints: n[d],
      size: h
    });
    if (a[d] = v, !w(v, h)) {
      let x = h - v, y = e < 0 ? f : l;
      for (; y >= 0 && y < n.length; ) {
        const L = a[y];
        z(
          L != null,
          `Previous layout not found for panel index ${y}`
        );
        const P = L + x, E = F({
          panelConstraints: n[y],
          size: P
        });
        if (w(L, E) || (x -= E - L, a[y] = E), w(x, 0))
          break;
        e > 0 ? y-- : y++;
      }
    }
  }
  const m = Object.values(a).reduce(
    (d, p) => p + d,
    0
  );
  if (!w(m, 100, 0.1))
    return r;
  const g = Object.keys(r);
  return a.reduce((d, p, h) => (d[g[h]] = p, d), {});
}
function U(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const n in e)
    if (j(e[n], t[n]) !== 0)
      return !1;
  return !0;
}
function Ce({
  event: e,
  hitRegions: t,
  initialLayoutMap: n,
  mountedGroups: o,
  pointerDownAtPoint: r
}) {
  let s = 0;
  const c = new Map(o);
  t.forEach((i) => {
    const { group: a, groupSize: l } = i, { disableCursor: f, orientation: u, panels: m } = a;
    let g = 0;
    r ? u === "horizontal" ? g = (e.clientX - r.x) / l * 100 : g = (e.clientY - r.y) / l * 100 : u === "horizontal" ? g = e.clientX < 0 ? -100 : 100 : g = e.clientY < 0 ? -100 : 100;
    const d = n.get(a), {
      derivedPanelConstraints: p,
      layout: h,
      separatorToPanels: v
    } = o.get(a) ?? {};
    if (p && d && h && v) {
      const x = B({
        delta: g,
        initialLayout: d,
        panelConstraints: p,
        pivotIndices: i.panels.map((S) => m.indexOf(S)),
        prevLayout: h,
        trigger: "mouse-or-touch"
      });
      if (U(x, h)) {
        if (g !== 0 && !f)
          switch (u) {
            case "horizontal": {
              s |= g < 0 ? Le : Pe;
              break;
            }
            case "vertical": {
              s |= g < 0 ? Ee : Re;
              break;
            }
          }
      } else {
        c.set(i.group, {
          derivedPanelConstraints: p,
          layout: x,
          separatorToPanels: v
        });
        const S = i.group.panels.map(({ id: y }) => y).join(",");
        i.group.inMemoryLayouts[S] = x;
      }
    }
  }), C({
    cursorFlags: s,
    mountedGroups: c
  }), le();
}
function he(e) {
  if (e.defaultPrevented)
    return;
  if (e.relatedTarget !== null)
    return;
  if (e.clientX === 0 && e.clientY === 0)
    return;
  const { interactionState: t, mountedGroups: n } = O();
  switch (t.state) {
    case "active":
      t.hitRegions.forEach((o) => {
        e.currentTarget === o.group.element && Ce({
          event: e,
          hitRegions: t.hitRegions,
          initialLayoutMap: t.initialLayoutMap,
          mountedGroups: n
        });
      });
  }
}
function ee(e) {
  const t = e.parentElement;
  z(t, "Parent group element not found");
  const { mountedGroups: n } = O();
  for (const [o] of n)
    if (o.element === t)
      return o;
  throw Error("Could not find parent Group for separator element");
}
function $({
  layout: e,
  panelConstraints: t
}) {
  const o = [...Object.values(e)], r = o.reduce(
    (i, a) => i + a,
    0
  );
  if (o.length !== t.length)
    throw Error(
      `Invalid ${t.length} panel layout: ${o.map((i) => `${i}%`).join(", ")}`
    );
  if (!w(r, 100) && o.length > 0)
    for (let i = 0; i < t.length; i++) {
      const a = o[i];
      z(a != null, `No layout data found for index ${i}`);
      const l = 100 / r * a;
      o[i] = l;
    }
  let s = 0;
  for (let i = 0; i < t.length; i++) {
    const a = o[i];
    z(a != null, `No layout data found for index ${i}`);
    const l = F({
      panelConstraints: t[i],
      size: a
    });
    a != l && (s += a - l, o[i] = l);
  }
  if (!w(s, 0))
    for (let i = 0; i < t.length; i++) {
      const a = o[i];
      z(a != null, `No layout data found for index ${i}`);
      const l = a + s, f = F({
        panelConstraints: t[i],
        size: l
      });
      if (a !== f && (s -= f - a, o[i] = f, w(s, 0)))
        break;
    }
  const c = Object.keys(e);
  return o.reduce((i, a, l) => (i[c[l]] = a, i), {});
}
function Me({
  groupId: e
}) {
  const t = () => {
    const { mountedGroups: n } = O();
    for (const [o, r] of n)
      if (o.id === e)
        return { group: o, ...r };
    throw Error(`Group ${e} not found`);
  };
  return {
    getLayout() {
      const { layout: n } = t();
      return n;
    },
    setLayout(n) {
      const {
        derivedPanelConstraints: o,
        group: r,
        layout: s,
        separatorToPanels: c
      } = t(), i = $({
        layout: n,
        panelConstraints: o
      });
      return U(s, i) || C((a) => ({
        mountedGroups: new Map(a.mountedGroups).set(r, {
          derivedPanelConstraints: o,
          layout: i,
          separatorToPanels: c
        })
      })), i;
    }
  };
}
function Ge(e) {
  const { mountedGroups: t } = O(), n = t.get(e);
  return z(n, `Mounted Group ${e.id} not found`), n;
}
function D(e, t) {
  const n = ee(e), o = Ge(n), r = n.separators.find(
    (u) => u.element === e
  );
  z(r, "Matching separator not found");
  const s = o.separatorToPanels.get(r);
  z(s, "Matching panels not found");
  const c = s.map((u) => n.panels.indexOf(u)), a = Me({ groupId: n.id }).getLayout(), l = B({
    delta: t,
    initialLayout: a,
    panelConstraints: o.derivedPanelConstraints,
    pivotIndices: c,
    prevLayout: a,
    trigger: "keyboard"
  }), f = $({
    layout: l,
    panelConstraints: o.derivedPanelConstraints
  });
  U(a, f) || C((u) => ({
    mountedGroups: new Map(u.mountedGroups).set(n, {
      derivedPanelConstraints: o.derivedPanelConstraints,
      layout: f,
      separatorToPanels: o.separatorToPanels
    })
  }));
}
function ve(e) {
  if (e.defaultPrevented)
    return;
  const t = e.currentTarget, n = ee(t);
  if (!n.disabled)
    switch (e.key) {
      case "ArrowDown": {
        e.preventDefault(), n.orientation === "vertical" && D(t, 5);
        break;
      }
      case "ArrowLeft": {
        e.preventDefault(), n.orientation === "horizontal" && D(t, -5);
        break;
      }
      case "ArrowRight": {
        e.preventDefault(), n.orientation === "horizontal" && D(t, 5);
        break;
      }
      case "ArrowUp": {
        e.preventDefault(), n.orientation === "vertical" && D(t, -5);
        break;
      }
      case "End": {
        e.preventDefault(), D(t, 100);
        break;
      }
      case "Enter": {
        e.preventDefault();
        const o = ee(t), { derivedPanelConstraints: r, layout: s, separatorToPanels: c } = Ge(o), i = o.separators.find(
          (u) => u.element === t
        );
        z(i, "Matching separator not found");
        const a = c.get(i);
        z(a, "Matching panels not found");
        const l = a[0], f = r.find(
          (u) => u.panelId === l.id
        );
        if (z(f, "Panel metadata not found"), f.collapsible) {
          const u = s[l.id], m = f.collapsedSize === u ? o.inMemoryLastExpandedPanelSizes[l.id] ?? f.minSize : f.collapsedSize;
          D(t, m - u);
        }
        break;
      }
      case "F6": {
        e.preventDefault();
        const r = ee(t).separators.map(
          (a) => a.element
        ), s = Array.from(r).findIndex(
          (a) => a === e.currentTarget
        );
        z(s !== null, "Index not found");
        const c = e.shiftKey ? s > 0 ? s - 1 : r.length - 1 : s + 1 < r.length ? s + 1 : 0;
        r[c].focus();
        break;
      }
      case "Home": {
        e.preventDefault(), D(t, -100);
        break;
      }
    }
}
function et(e, t) {
  return {
    x: e.x >= t.left && e.x <= t.right ? 0 : Math.min(
      Math.abs(e.x - t.left),
      Math.abs(e.x - t.right)
    ),
    y: e.y >= t.top && e.y <= t.bottom ? 0 : Math.min(
      Math.abs(e.y - t.top),
      Math.abs(e.y - t.bottom)
    )
  };
}
function tt(e, t, n) {
  let o, r = {
    x: 1 / 0,
    y: 1 / 0
  };
  for (const s of t) {
    const c = et(n, s.rect);
    switch (e) {
      case "horizontal": {
        c.x <= r.x && (o = s, r = c);
        break;
      }
      case "vertical": {
        c.y <= r.y && (o = s, r = c);
        break;
      }
    }
  }
  return o ? {
    distance: r,
    hitRegion: o
  } : void 0;
}
let Q;
function nt() {
  return Q === void 0 && (typeof matchMedia == "function" ? Q = !!matchMedia("(pointer:coarse)").matches : Q = !1), Q;
}
function Ie(e, t) {
  const n = [];
  return t.forEach((o, r) => {
    if (r.disabled)
      return;
    const s = nt() ? me.coarse : me.precise, c = we(r), i = tt(r.orientation, c, {
      x: e.clientX,
      y: e.clientY
    });
    i && i.distance.x <= s && i.distance.y <= s && n.push(i.hitRegion);
  }), n;
}
function ge(e) {
  if (e.defaultPrevented)
    return;
  const { mountedGroups: t } = O(), n = Ie(e, t), o = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Map();
  let i = !1;
  n.forEach((a) => {
    o.add(a.group), a.panels.forEach((f) => {
      r.add(f);
    }), a.separator && (s.add(a.separator), i || (i = !0, a.separator.element.focus()));
    const l = t.get(a.group);
    l && c.set(a.group, l.layout);
  }), C({
    interactionState: {
      hitRegions: n,
      initialLayoutMap: c,
      pointerDownAtPoint: { x: e.clientX, y: e.clientY },
      state: "active"
    }
  }), n.length && e.preventDefault();
}
function ye(e) {
  if (e.defaultPrevented)
    return;
  const { interactionState: t, mountedGroups: n } = O();
  switch (t.state) {
    case "active": {
      if (
        // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
        e.type !== "pointerleave" && e.buttons === 0
      ) {
        C(
          (o) => o.interactionState.state === "inactive" ? o : {
            cursorFlags: 0,
            interactionState: {
              state: "inactive"
            }
          }
        );
        return;
      }
      Ce({
        event: e,
        hitRegions: t.hitRegions,
        initialLayoutMap: t.initialLayoutMap,
        mountedGroups: n,
        pointerDownAtPoint: t.pointerDownAtPoint
      });
      break;
    }
    default: {
      const o = Ie(e, n);
      o.length === 0 ? t.state !== "inactive" && C({
        interactionState: { state: "inactive" }
      }) : C({
        interactionState: {
          hitRegions: o,
          state: "hover"
        }
      }), le();
      break;
    }
  }
}
function Se(e) {
  if (e.defaultPrevented)
    return;
  e.preventDefault();
  const { interactionState: t } = O();
  switch (t.state) {
    case "active":
      C({
        cursorFlags: 0,
        interactionState: {
          state: "inactive"
        }
      }), le();
  }
}
function ot(e) {
  let t = 0, n = 0;
  const o = {};
  for (const s of e)
    if (s.defaultSize !== void 0) {
      t++;
      const c = I(s.defaultSize);
      n += c, o[s.panelId] = c;
    } else
      o[s.panelId] = void 0;
  const r = e.length - t;
  if (r !== 0) {
    const s = I((100 - n) / r);
    for (const c of e)
      c.defaultSize === void 0 && (o[c.panelId] = s);
  }
  return o;
}
function it(e, t, n) {
  const o = n[0];
  if (!o)
    return;
  const r = e.panels.find((c) => c.element === t);
  if (!r || !r.onResize)
    return;
  const s = te({ group: e });
  r.onResize(
    {
      asPercentage: I(
        o.inlineSize / s * 100
      ),
      inPixels: o.inlineSize
    },
    r.id
  );
}
function st(e) {
  let t = !0;
  z(
    e.separators.length === 0 || e.separators.length < e.panels.length,
    "Invalid Group configuration; too many Separator components"
  );
  const n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r = new ResizeObserver((u) => {
    for (const m of u) {
      const { borderBoxSize: g, target: d } = m;
      d === e.element ? t && C((p) => {
        const h = p.mountedGroups.get(e);
        if (h) {
          const v = pe(e), x = h.layout, S = $({
            layout: x,
            panelConstraints: v
          });
          return {
            mountedGroups: new Map(p.mountedGroups).set(e, {
              derivedPanelConstraints: v,
              layout: S,
              separatorToPanels: h.separatorToPanels
            })
          };
        }
        return p;
      }) : it(e, d, g);
    }
  });
  r.observe(e.element), e.panels.forEach((u) => {
    z(
      !n.has(u.id),
      `Panel ids must be unique; id "${u.id}" was used more than once`
    ), n.add(u.id), u.onResize && r.observe(u.element);
  });
  const s = pe(e), c = e.panels.map(({ id: u }) => u).join(","), i = e.inMemoryLayouts[c] ?? e.defaultLayout ?? ot(s), a = $({
    layout: i,
    panelConstraints: s
  }), l = we(e), f = C((u) => ({
    mountedGroups: new Map(u.mountedGroups).set(e, {
      derivedPanelConstraints: s,
      layout: a,
      separatorToPanels: new Map(
        l.filter((m) => m.separator).map((m) => [m.separator, m.panels])
      )
    })
  }));
  return e.element.addEventListener("pointerleave", he), e.separators.forEach((u) => {
    z(
      !o.has(u.id),
      `Separator ids must be unique; id "${u.id}" was used more than once`
    ), o.add(u.id), u.element.addEventListener("keydown", ve);
  }), f.mountedGroups.size === 1 && (window.addEventListener("pointerdown", ge), window.addEventListener("pointermove", ye), window.addEventListener("pointerup", Se)), function() {
    t = !1;
    const m = C((g) => {
      const d = new Map(g.mountedGroups);
      return d.delete(e), { mountedGroups: d };
    });
    e.element.removeEventListener("pointerleave", he), e.separators.forEach((g) => {
      g.element.removeEventListener("keydown", ve);
    }), m.mountedGroups.size === 0 && (window.removeEventListener("pointerdown", ge), window.removeEventListener("pointermove", ye), window.removeEventListener("pointerup", Se)), r.disconnect();
  };
}
function ce(e) {
  const t = $e();
  return `${e ?? t}`;
}
const H = typeof window < "u" ? Ne : _e;
function ue(e) {
  const t = T(e);
  return H(() => {
    t.current = e;
  }, [e]), xe((n) => t.current?.(n), [t]);
}
function fe(...e) {
  return ue((t) => {
    e.forEach((n) => {
      if (n)
        switch (typeof n) {
          case "function": {
            n(t);
            break;
          }
          case "object": {
            n.current = t;
            break;
          }
        }
    });
  });
}
const ke = "--react-resizable-panels--panel--pointer-events";
function Oe(e, t) {
  const n = e.replace(/[^a-zA-Z0-9\-_]/g, ""), o = t.replace(/[^a-zA-Z0-9\-_]/g, "");
  return `--react-resizable-panels--${n}--${o}`;
}
const Te = Fe(null);
function rt(e, t) {
  const n = T({
    getLayout: () => ({}),
    setLayout: Ze
  });
  ze(t, () => n.current, []), H(() => {
    Object.assign(
      n.current,
      Me({ groupId: e })
    );
  });
}
function ht({
  children: e,
  className: t,
  defaultLayout: n,
  disableCursor: o,
  disabled: r,
  elementRef: s,
  groupRef: c,
  id: i,
  onLayoutChange: a,
  orientation: l = "horizontal",
  style: f,
  ...u
}) {
  const m = T({}), g = ue((b) => {
    U(m.current, b) || (m.current = b, a?.(b));
  }), d = ce(i), [p, h] = G(!1), [v, x] = G(null), [S, y] = G(n ?? {}), [L, P] = G([]), [E, K] = G([]), ne = T({}), V = T({}), X = fe(x, s);
  rt(d, c);
  const Y = be(
    () => ({
      id: d,
      orientation: l,
      registerPanel: (b) => (P((M) => re(l, [...M, b])), () => {
        P((M) => M.filter((N) => N !== b));
      }),
      registerSeparator: (b) => (K(
        (M) => re(l, [...M, b])
      ), () => {
        K(
          (M) => M.filter((N) => N !== b)
        );
      })
    }),
    [d, l]
  );
  H(() => {
    if (v !== null && L.length > 0) {
      const b = {
        defaultLayout: n,
        disableCursor: !!o,
        disabled: !!r,
        element: v,
        id: d,
        inMemoryLastExpandedPanelSizes: ne.current,
        inMemoryLayouts: V.current,
        orientation: l,
        panels: L,
        separators: E
      }, M = st(b), oe = O().mountedGroups.get(b);
      oe && (y(oe.layout), g?.(oe.layout));
      const De = A.addListener(
        "interactionStateChange",
        (Z) => {
          switch (Z.state) {
            case "active": {
              h(
                Z.hitRegions.some(
                  (_) => _.group === b
                )
              );
              break;
            }
            default: {
              h(!1);
              break;
            }
          }
        }
      ), Ae = A.addListener(
        "mountedGroupsChange",
        (Z) => {
          const _ = Z.get(b);
          _ && _.derivedPanelConstraints.length > 0 && (y(_.layout), g?.(_.layout));
        }
      );
      return () => {
        M(), De(), Ae();
      };
    }
  }, [
    n,
    o,
    r,
    v,
    d,
    g,
    l,
    L,
    E
  ]);
  const q = {
    [ke]: p ? "none" : void 0
  };
  for (const b in S) {
    const M = Oe(d, b), N = S[b];
    q[M] = N;
  }
  return /* @__PURE__ */ W(Te.Provider, { value: Y, children: /* @__PURE__ */ W(
    "div",
    {
      ...u,
      "aria-orientation": l,
      className: t,
      "data-group": !0,
      "data-testid": d,
      id: d,
      ref: X,
      style: {
        ...f,
        ...q,
        display: "flex",
        flexDirection: l === "horizontal" ? "row" : "column",
        flexWrap: "nowrap"
      },
      children: e
    }
  ) });
}
function ae(e) {
  return `react-resizable-panels:${e}`;
}
function at({
  id: e,
  layout: t,
  storage: n
}) {
  try {
    const o = ae(e);
    n.setItem(o, JSON.stringify(t));
  } catch (o) {
    console.error(o);
  }
}
function vt({
  groupId: e,
  storage: t
}) {
  const n = He(
    lt,
    () => t.getItem(ae(e)),
    () => t.getItem(ae(e))
  ), o = be(
    () => n ? JSON.parse(n) : void 0,
    [n]
  ), r = xe(
    (s) => at({
      id: e,
      layout: s,
      storage: t
    }),
    [e, t]
  );
  return {
    defaultLayout: o,
    onLayoutChange: r
  };
}
function lt() {
  return function() {
  };
}
function gt() {
  return G(null);
}
function yt() {
  return T(null);
}
function de() {
  const e = We(Te);
  return z(
    e,
    "Group Context not found; did you render a Panel or Separator outside of a Group?"
  ), e;
}
function ct({
  groupId: e,
  panelId: t
}) {
  const n = () => {
    const { mountedGroups: i } = O();
    for (const [
      a,
      { derivedPanelConstraints: l, layout: f, separatorToPanels: u }
    ] of i)
      if (a.id === e)
        return { derivedPanelConstraints: l, group: a, layout: f, separatorToPanels: u };
    throw Error(`Group ${e} not found`);
  }, o = () => {
    const i = n().derivedPanelConstraints.find(
      (a) => a.panelId === t
    );
    if (i !== void 0)
      return i;
    throw Error(`Panel constraints not found for Panel ${t}`);
  }, r = () => {
    const i = n().group.panels.find((a) => a.id === t);
    if (i !== void 0)
      return i;
    throw Error(`Layout not found for Panel ${t}`);
  }, s = () => {
    const i = n().layout[t];
    if (i !== void 0)
      return i;
    throw Error(`Layout not found for Panel ${t}`);
  }, c = (i) => {
    const a = s();
    if (i === a)
      return;
    const {
      derivedPanelConstraints: l,
      group: f,
      layout: u,
      separatorToPanels: m
    } = n(), g = f.panels.findIndex((v) => v.id === t), d = g === f.panels.length - 1, p = B({
      delta: d ? a - i : i - a,
      initialLayout: u,
      panelConstraints: l,
      pivotIndices: d ? [g - 1, g] : [g, g + 1],
      prevLayout: u,
      trigger: "imperative-api"
    }), h = $({
      layout: p,
      panelConstraints: l
    });
    U(u, h) || C((v) => ({
      mountedGroups: new Map(v.mountedGroups).set(f, {
        derivedPanelConstraints: l,
        layout: h,
        separatorToPanels: m
      })
    }));
  };
  return {
    collapse: () => {
      const { collapsible: i, collapsedSize: a } = o(), l = s();
      i && l !== a && c(a);
    },
    expand: () => {
      const { collapsible: i, collapsedSize: a, minSize: l } = o(), f = s();
      i && f === a && c(l);
    },
    getSize: () => {
      const { group: i } = n(), a = s(), { element: l } = r(), f = i.orientation === "horizontal" ? l.offsetWidth : l.offsetHeight;
      return {
        asPercentage: a,
        inPixels: f
      };
    },
    isCollapsed: () => {
      const { collapsible: i, collapsedSize: a } = o(), l = s();
      return i && w(a, l);
    },
    resize: (i) => {
      if (s() !== i) {
        let l;
        switch (typeof i) {
          case "number": {
            const { group: f } = n(), u = te({ group: f });
            l = I(i / u * 100);
            break;
          }
          case "string": {
            l = parseFloat(i);
            break;
          }
        }
        c(l);
      }
    }
  };
}
function ut(e, t) {
  const { id: n } = de(), o = T({
    collapse: ie,
    expand: ie,
    getSize: () => ({
      asPercentage: 0,
      inPixels: 0
    }),
    isCollapsed: () => !1,
    resize: ie
  });
  ze(t, () => o.current, []), H(() => {
    Object.assign(
      o.current,
      ct({ groupId: n, panelId: e })
    );
  });
}
function St({
  children: e,
  className: t,
  collapsedSize: n = "0%",
  collapsible: o = !1,
  defaultSize: r,
  elementRef: s,
  id: c,
  maxSize: i = "100%",
  minSize: a = "0%",
  onResize: l,
  panelRef: f,
  style: u,
  ...m
}) {
  const g = !!c, d = ce(c), [p, h] = G(null), v = fe(h, s), { id: x, registerPanel: S } = de(), y = l !== null, L = ue((E) => {
    l?.(E, c);
  });
  H(() => {
    if (p !== null)
      return S({
        element: p,
        id: d,
        idIsStable: g,
        onResize: y ? L : void 0,
        panelConstraints: {
          collapsedSize: n,
          collapsible: o,
          defaultSize: r,
          maxSize: i,
          minSize: a
        }
      });
  }, [
    n,
    o,
    r,
    p,
    y,
    d,
    g,
    i,
    a,
    L,
    S
  ]), ut(d, f);
  const P = Oe(x, d);
  return /* @__PURE__ */ W(
    "div",
    {
      ...m,
      "data-panel": !0,
      "data-testid": d,
      id: d,
      ref: v,
      style: {
        ...ft,
        flexBasis: 0,
        flexGrow: `var(${P}, 1)`,
        flexShrink: 1,
        // Prevent Panel content from interfering with panel size
        overflow: "hidden",
        // Disable pointer events inside of a panel during resize
        // This avoid edge cases like nested iframes
        pointerEvents: `var(${ke})`
      },
      children: /* @__PURE__ */ W(
        "div",
        {
          className: t,
          style: {
            width: "100%",
            height: "100%",
            ...u
          },
          children: e
        }
      )
    }
  );
}
const ft = {
  minHeight: "unset",
  maxHeight: "unset",
  height: "unset",
  minWidth: "unset",
  maxWidth: "unset",
  width: "unset",
  flex: "unset",
  flexBasis: "unset",
  flexShrink: "unset",
  flexGrow: "unset",
  border: "unset",
  borderWidth: "unset",
  padding: "unset",
  margin: "unset"
};
function xt() {
  return G(null);
}
function zt() {
  return T(null);
}
function dt({
  layout: e,
  panelConstraints: t,
  panelId: n,
  panelIndex: o
}) {
  let r, s;
  const c = e[n], i = t.find(
    (a) => a.panelId === n
  );
  if (i) {
    const a = i.maxSize, l = s = i.collapsible ? i.collapsedSize : i.minSize, f = [o, o + 1];
    s = $({
      layout: B({
        delta: l - c,
        initialLayout: e,
        panelConstraints: t,
        pivotIndices: f,
        prevLayout: e,
        trigger: "keyboard"
      }),
      panelConstraints: t
    })[n], r = $({
      layout: B({
        delta: a - c,
        initialLayout: e,
        panelConstraints: t,
        pivotIndices: f,
        prevLayout: e,
        trigger: "keyboard"
      }),
      panelConstraints: t
    })[n];
  }
  return {
    valueControls: n,
    valueMax: r,
    valueMin: s,
    valueNow: c
  };
}
function bt({
  children: e,
  className: t,
  elementRef: n,
  id: o,
  style: r,
  ...s
}) {
  const c = ce(o), [i, a] = G({}), [l, f] = G("inactive"), [u, m] = G(null), g = fe(m, n), {
    id: d,
    orientation: p,
    registerSeparator: h
  } = de(), v = p === "horizontal" ? "vertical" : "horizontal";
  return H(() => {
    if (u !== null) {
      const x = {
        element: u,
        id: c
      }, S = h(x), y = A.addListener(
        "interactionStateChange",
        (P) => {
          f(
            P.state !== "inactive" && P.hitRegions.some(
              (E) => E.separator === x
            ) ? P.state : "inactive"
          );
        }
      ), L = A.addListener(
        "mountedGroupsChange",
        (P) => {
          P.forEach(
            ({ derivedPanelConstraints: E, layout: K, separatorToPanels: ne }, V) => {
              if (V.id === d) {
                const X = ne.get(x);
                if (X) {
                  const Y = X[0], q = V.panels.indexOf(Y);
                  a(
                    dt({
                      layout: K,
                      panelConstraints: E,
                      panelId: Y.id,
                      panelIndex: q
                    })
                  );
                }
              }
            }
          );
        }
      );
      return () => {
        y(), L(), S();
      };
    }
  }, [u, d, c, h]), /* @__PURE__ */ W(
    "div",
    {
      ...s,
      "aria-controls": i.valueControls,
      "aria-orientation": v,
      "aria-valuemax": i.valueMax,
      "aria-valuemin": i.valueMin,
      "aria-valuenow": i.valueNow,
      children: e,
      className: t,
      "data-separator": l,
      "data-testid": c,
      id: c,
      ref: g,
      role: "separator",
      style: {
        flexBasis: "auto",
        ...r,
        flexGrow: 0,
        flexShrink: 0
      },
      tabIndex: 0
    }
  );
}
export {
  ht as Group,
  St as Panel,
  bt as Separator,
  vt as useDefaultLayout,
  gt as useGroupCallbackRef,
  yt as useGroupRef,
  xt as usePanelCallbackRef,
  zt as usePanelRef
};
//# sourceMappingURL=react-resizable-panels.js.map
