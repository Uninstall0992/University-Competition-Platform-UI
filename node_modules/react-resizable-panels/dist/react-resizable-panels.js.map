{"version":3,"file":"react-resizable-panels.js","sources":["../lib/utils/assert.ts","../lib/components/group/sortByElementOffset.ts","../lib/global/dom/calculateAvailableGroupSize.ts","../lib/global/dom/calculateHitRegions.ts","../lib/global/styles/convertEmToPixels.ts","../lib/global/styles/convertRemToPixels.ts","../lib/global/styles/convertVhToPixels.ts","../lib/global/styles/convertVwToPixels.ts","../lib/global/styles/parseSizeAndUnit.ts","../lib/global/styles/sizeStyleToPixels.ts","../lib/global/utils/formatLayoutNumber.ts","../lib/global/dom/calculatePanelConstraints.ts","../lib/utils/EventEmitter.ts","../lib/global/utils/layoutNumbersEqual.ts","../lib/global/mutableState.ts","../lib/constants.ts","../lib/global/cursor/getCursorStyle.ts","../lib/global/cursor/updateCursorStyle.ts","../lib/utils/isArrayEqual.ts","../lib/global/utils/compareLayoutNumbers.ts","../lib/global/utils/validatePanelSize.ts","../lib/global/utils/adjustLayoutByDelta.ts","../lib/global/utils/layoutsEqual.ts","../lib/global/utils/updateActiveHitRegion.ts","../lib/global/event-handlers/onGroupPointerLeave.ts","../lib/global/utils/findSeparatorGroup.ts","../lib/global/utils/validatePanelGroupLayout.ts","../lib/global/utils/getImperativeGroupMethods.ts","../lib/global/utils/getMountedGroup.ts","../lib/global/utils/adjustLayoutForSeparator.ts","../lib/global/event-handlers/onWindowKeyDown.ts","../lib/global/utils/getDistanceBetweenPointAndRect.ts","../lib/global/utils/findClosetHitRegion.ts","../lib/global/utils/isCoarsePointer.ts","../lib/global/utils/findMatchingHitRegions.ts","../lib/global/event-handlers/onWindowPointerDown.ts","../lib/global/event-handlers/onWindowPointerMove.ts","../lib/global/event-handlers/onWindowPointerUp.ts","../lib/global/utils/calculateDefaultLayout.ts","../lib/global/utils/notifyPanelOnResize.ts","../lib/global/mountGroup.ts","../lib/hooks/useId.ts","../lib/hooks/useIsomorphicLayoutEffect.ts","../lib/hooks/useStableCallback.ts","../lib/hooks/useMergedRefs.ts","../lib/components/panel/constants.ts","../lib/components/group/getPanelSizeCssPropertyName.ts","../lib/components/group/GroupContext.ts","../lib/components/group/useGroupImperativeHandle.ts","../lib/components/group/Group.tsx","../lib/components/group/auto-save/getStorageKey.ts","../lib/components/group/auto-save/saveGroupLayout.ts","../lib/components/group/useDefaultLayout.ts","../lib/components/group/useGroupCallbackRef.ts","../lib/components/group/useGroupRef.ts","../lib/components/group/useGroupContext.ts","../lib/global/utils/getImperativePanelMethods.ts","../lib/components/panel/usePanelImperativeHandle.ts","../lib/components/panel/Panel.tsx","../lib/components/panel/usePanelCallbackRef.ts","../lib/components/panel/usePanelRef.ts","../lib/global/utils/calculateSeparatorAriaValues.ts","../lib/components/separator/Separator.tsx"],"sourcesContent":["export function assert(\n  expectedCondition: unknown,\n  message: string = \"Assertion error\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    throw Error(message);\n  }\n}\n","import type { Orientation } from \"./types\";\n\nexport function sortByElementOffset<\n  Type extends { element: HTMLElement },\n  ReturnType extends Type[]\n>(orientation: Orientation, panelsOrSeparators: Type[]): ReturnType {\n  return panelsOrSeparators.sort(\n    orientation === \"horizontal\" ? horizontalSort : verticalSort\n  ) as ReturnType;\n}\n\nfunction horizontalSort<Type extends { element: HTMLElement }>(\n  a: Type,\n  b: Type\n) {\n  const delta = a.element.offsetLeft - b.element.offsetLeft;\n  if (delta !== 0) {\n    return delta;\n  }\n  return a.element.offsetWidth - b.element.offsetWidth;\n}\n\nfunction verticalSort<Type extends { element: HTMLElement }>(a: Type, b: Type) {\n  const delta = a.element.offsetTop - b.element.offsetTop;\n  if (delta !== 0) {\n    return delta;\n  }\n  return a.element.offsetHeight - b.element.offsetHeight;\n}\n","import type { RegisteredGroup } from \"../../components/group/types\";\n\nexport function calculateAvailableGroupSize({\n  group\n}: {\n  group: RegisteredGroup;\n}) {\n  const { orientation, panels } = group;\n\n  return panels.reduce((totalSize, panel) => {\n    totalSize +=\n      orientation === \"horizontal\"\n        ? panel.element.offsetWidth\n        : panel.element.offsetHeight;\n    return totalSize;\n  }, 0);\n}\n","import { sortByElementOffset } from \"../../components/group/sortByElementOffset\";\nimport type { RegisteredGroup } from \"../../components/group/types\";\nimport type { RegisteredPanel } from \"../../components/panel/types\";\nimport type { RegisteredSeparator } from \"../../components/separator/types\";\nimport { calculateAvailableGroupSize } from \"./calculateAvailableGroupSize\";\n\ntype PanelsTuple = [panel: RegisteredPanel, panel: RegisteredPanel];\n\nexport type HitRegion = {\n  group: RegisteredGroup;\n  groupSize: number;\n  panels: PanelsTuple;\n  rect: DOMRect;\n  separator: RegisteredSeparator | undefined;\n};\n\n/**\n * Determines hit regions for a Group; a hit region is either:\n * - 1: An explicit Separator element\n * - 2: The edge of a Panel element that has another Panel beside it\n *\n * This method determines bounding rects of all regions for the particular group.\n */\nexport function calculateHitRegions(group: RegisteredGroup) {\n  const { element: groupElement, orientation, panels, separators } = group;\n\n  // Sort elements by offset before traversing\n  const sortedChildElements: HTMLElement[] = sortByElementOffset(\n    orientation,\n    Array.from(groupElement.children)\n      .filter((child) => child instanceof HTMLElement)\n      .map((element) => ({ element }))\n  ).map(({ element }) => element);\n\n  const hitRegions: HitRegion[] = [];\n\n  let prevPanel: RegisteredPanel | undefined = undefined;\n  let prevSeparator: RegisteredSeparator | undefined = undefined;\n\n  for (const childElement of sortedChildElements) {\n    const panelData = panels.find(\n      (current) => current.element === childElement\n    );\n    if (panelData) {\n      if (prevPanel) {\n        const prevRect = prevPanel.element.getBoundingClientRect();\n        const rect = childElement.getBoundingClientRect();\n\n        hitRegions.push({\n          group,\n          groupSize: calculateAvailableGroupSize({ group }),\n          panels: [prevPanel, panelData],\n          separator: prevSeparator,\n          rect:\n            orientation === \"horizontal\"\n              ? new DOMRect(\n                  prevRect.right,\n                  rect.top,\n                  rect.left - prevRect.right,\n                  rect.height\n                )\n              : new DOMRect(\n                  rect.left,\n                  prevRect.bottom,\n                  rect.width,\n                  rect.top - prevRect.bottom\n                )\n        });\n      }\n\n      prevPanel = panelData;\n      prevSeparator = undefined;\n    } else {\n      const separatorData = separators.find(\n        (current) => current.element === childElement\n      );\n      if (separatorData) {\n        // No-op; this area will be included by default when closing the next panel\n        prevSeparator = separatorData;\n      } else {\n        prevPanel = undefined;\n        prevSeparator = undefined;\n      }\n    }\n  }\n\n  return hitRegions;\n}\n","export function convertEmToPixels(element: Element, value: number) {\n  const style = getComputedStyle(element);\n  const fontSize = parseFloat(style.fontSize);\n\n  return value * fontSize;\n}\n","export function convertRemToPixels(element: Element, value: number) {\n  const style = getComputedStyle(element.ownerDocument.body);\n  const fontSize = parseFloat(style.fontSize);\n\n  return value * fontSize;\n}\n","export function convertVhToPixels(value: number) {\n  return (value / 100) * window.innerHeight;\n}\n","export function convertVwToPixels(value: number) {\n  return (value / 100) * window.innerWidth;\n}\n","import type { SizeUnit } from \"../../components/panel/types\";\n\nexport function parseSizeAndUnit(\n  size: number | string\n): [numeric: number, size: SizeUnit] {\n  switch (typeof size) {\n    case \"number\": {\n      return [size, \"px\"];\n    }\n    case \"string\": {\n      const numeric = parseFloat(size);\n\n      if (size.endsWith(\"%\")) {\n        return [numeric, \"%\"];\n      } else if (size.endsWith(\"px\")) {\n        return [numeric, \"px\"];\n      } else if (size.endsWith(\"rem\")) {\n        return [numeric, \"rem\"];\n      } else if (size.endsWith(\"em\")) {\n        return [numeric, \"em\"];\n      } else if (size.endsWith(\"vh\")) {\n        return [numeric, \"vh\"];\n      } else if (size.endsWith(\"vw\")) {\n        return [numeric, \"vw\"];\n      }\n\n      return [numeric, \"%\"];\n    }\n  }\n}\n","import { convertEmToPixels } from \"./convertEmToPixels\";\nimport { convertRemToPixels } from \"./convertRemToPixels\";\nimport { convertVhToPixels } from \"./convertVhToPixels\";\nimport { convertVwToPixels } from \"./convertVwToPixels\";\nimport { parseSizeAndUnit } from \"./parseSizeAndUnit\";\n\nexport function sizeStyleToPixels({\n  groupSize,\n  panelElement,\n  styleProp\n}: {\n  groupSize: number;\n  panelElement: HTMLElement;\n  styleProp: number | string;\n}) {\n  let pixels: number | undefined = undefined;\n\n  const [size, unit] = parseSizeAndUnit(styleProp);\n\n  switch (unit) {\n    case \"%\": {\n      pixels = (size / 100) * groupSize;\n      break;\n    }\n    case \"px\": {\n      pixels = size;\n      break;\n    }\n    case \"rem\": {\n      pixels = convertRemToPixels(panelElement, size);\n      break;\n    }\n    case \"em\": {\n      pixels = convertEmToPixels(panelElement, size);\n      break;\n    }\n    case \"vh\": {\n      pixels = convertVhToPixels(size);\n      break;\n    }\n    case \"vw\": {\n      pixels = convertVwToPixels(size);\n      break;\n    }\n  }\n\n  return pixels;\n}\n","export function formatLayoutNumber(number: number) {\n  return parseFloat(number.toFixed(3));\n}\n","import type { RegisteredGroup } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { sizeStyleToPixels } from \"../styles/sizeStyleToPixels\";\nimport { formatLayoutNumber } from \"../utils/formatLayoutNumber\";\nimport { calculateAvailableGroupSize } from \"./calculateAvailableGroupSize\";\n\nexport function calculatePanelConstraints(group: RegisteredGroup) {\n  const { panels } = group;\n\n  const groupSize = calculateAvailableGroupSize({ group });\n\n  return panels.map<PanelConstraints>((panel) => {\n    const { element, panelConstraints } = panel;\n\n    let collapsedSize = 0;\n    if (panelConstraints.collapsedSize) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.collapsedSize\n      });\n\n      collapsedSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    let defaultSize: number | undefined = undefined;\n    if (panelConstraints.defaultSize) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.defaultSize\n      });\n\n      defaultSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    let minSize = 0;\n    if (panelConstraints.minSize) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.minSize\n      });\n\n      minSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    let maxSize = 100;\n    if (panelConstraints.maxSize) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.maxSize\n      });\n\n      maxSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    return {\n      collapsedSize,\n      collapsible: panelConstraints.collapsible === true,\n      defaultSize,\n      minSize,\n      maxSize,\n      panelId: panel.id\n    };\n  });\n}\n","export type EventMap = {\n  [key: string]: unknown;\n};\n\nexport type EventListener<Data> = (data: Data) => void;\n\nexport class EventEmitter<Events extends EventMap> {\n  #listenerMap: {\n    [Key in keyof Events]?: EventListener<Events[Key]>[];\n  } = {};\n\n  addListener<Type extends keyof Events>(\n    type: Type,\n    listener: EventListener<Events[Type]>\n  ) {\n    const listeners = this.#listenerMap[type];\n    if (listeners === undefined) {\n      this.#listenerMap[type] = [listener];\n    } else {\n      if (!listeners.includes(listener)) {\n        listeners.push(listener);\n      }\n    }\n\n    return () => {\n      this.removeListener(type, listener);\n    };\n  }\n\n  emit<Type extends keyof Events>(type: Type, data: Events[Type]) {\n    const listeners = this.#listenerMap[type];\n    if (listeners !== undefined) {\n      if (listeners.length === 1) {\n        const listener = listeners[0];\n        listener.call(null, data);\n      } else {\n        let didThrow = false;\n        let caughtError = null;\n\n        // Clone the current listeners before calling\n        // in case calling triggers listeners to be added or removed\n        const clonedListeners = Array.from(listeners);\n        for (let i = 0; i < clonedListeners.length; i++) {\n          const listener = clonedListeners[i];\n          try {\n            listener.call(null, data);\n          } catch (error) {\n            if (caughtError === null) {\n              didThrow = true;\n              caughtError = error;\n            }\n          }\n        }\n\n        if (didThrow) {\n          throw caughtError;\n        }\n      }\n    }\n  }\n\n  removeAllListeners() {\n    this.#listenerMap = {};\n  }\n\n  removeListener<Type extends keyof Events>(\n    type: Type,\n    listener: EventListener<Events[Type]>\n  ) {\n    const listeners = this.#listenerMap[type];\n    if (listeners !== undefined) {\n      const index = listeners.indexOf(listener);\n      if (index >= 0) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n","import { formatLayoutNumber } from \"./formatLayoutNumber\";\n\nexport function layoutNumbersEqual(\n  actual: number,\n  expected: number,\n  minimumDelta = 0\n) {\n  return (\n    Math.abs(formatLayoutNumber(actual) - formatLayoutNumber(expected)) <=\n    minimumDelta\n  );\n}\n","import type { Layout, RegisteredGroup } from \"../components/group/types\";\nimport type {\n  PanelConstraints,\n  RegisteredPanel\n} from \"../components/panel/types\";\nimport type { RegisteredSeparator } from \"../components/separator/types\";\nimport { EventEmitter } from \"../utils/EventEmitter\";\nimport type { InteractionState } from \"./types\";\nimport { layoutNumbersEqual } from \"./utils/layoutNumbersEqual\";\n\ntype UpdaterFunction = (prevState: State) => Partial<State>;\n\nexport type SeparatorToPanelsMap = Map<\n  RegisteredSeparator,\n  [primaryPanel: RegisteredPanel, secondaryPanel: RegisteredPanel]\n>;\n\nexport type MountedGroupMap = Map<\n  RegisteredGroup,\n  {\n    derivedPanelConstraints: PanelConstraints[];\n    layout: Layout;\n    separatorToPanels: SeparatorToPanelsMap;\n  }\n>;\n\ntype Events = {\n  cursorFlagsChange: number;\n  interactionStateChange: InteractionState;\n  mountedGroupsChange: MountedGroupMap;\n};\n\ntype State = {\n  cursorFlags: number;\n  interactionState: InteractionState;\n  mountedGroups: MountedGroupMap;\n};\n\nlet state: State = {\n  cursorFlags: 0,\n  interactionState: {\n    state: \"inactive\"\n  },\n  mountedGroups: new Map()\n};\n\nexport const eventEmitter = new EventEmitter<Events>();\n\nexport function read(): State {\n  return state;\n}\n\nexport function update(value: Partial<State> | UpdaterFunction) {\n  const partialState = typeof value === \"function\" ? value(state) : value;\n  if (state === partialState) {\n    return state;\n  }\n\n  const prevState = state;\n\n  state = {\n    ...state,\n    ...partialState\n  };\n\n  if (partialState.cursorFlags !== undefined) {\n    eventEmitter.emit(\"cursorFlagsChange\", state.cursorFlags);\n  }\n\n  if (partialState.interactionState !== undefined) {\n    eventEmitter.emit(\"interactionStateChange\", state.interactionState);\n  }\n\n  if (partialState.mountedGroups !== undefined) {\n    // If any collapsible Panels have been collapsed by this size change, record their previous sizes\n    state.mountedGroups.forEach((value, group) => {\n      value.derivedPanelConstraints.forEach((constraints) => {\n        if (constraints.collapsible) {\n          const { layout: prevLayout } =\n            prevState.mountedGroups.get(group) ?? {};\n          if (prevLayout) {\n            const isCollapsed = layoutNumbersEqual(\n              constraints.collapsedSize,\n              value.layout[constraints.panelId]\n            );\n            const wasCollapsed = layoutNumbersEqual(\n              constraints.collapsedSize,\n              prevLayout[constraints.panelId]\n            );\n            if (isCollapsed && !wasCollapsed) {\n              group.inMemoryLastExpandedPanelSizes[constraints.panelId] =\n                prevLayout[constraints.panelId];\n            }\n          }\n        }\n      });\n    });\n\n    eventEmitter.emit(\"mountedGroupsChange\", state.mountedGroups);\n  }\n\n  return state;\n}\n","// Constants used for memoization\nexport const EMPTY_ARRAY: unknown[] = [];\nexport const EMPTY_DOM_RECT: DOMRectReadOnly = {\n  bottom: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  toJSON: () => {},\n  top: 0,\n  width: 0,\n  x: 0,\n  y: 0\n};\nexport const EMPTY_OBJECT = {};\nexport const EMPTY_POINT = { x: 0, y: 0 };\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const IDENTITY_FUNCTION = (value: any) => value;\nexport const NOOP_FUNCTION = () => {};\n\n// Cursor flags\nexport const CURSOR_FLAG_HORIZONTAL_MIN = 0b0001;\nexport const CURSOR_FLAG_HORIZONTAL_MAX = 0b0010;\nexport const CURSOR_FLAG_VERTICAL_MIN = 0b0100;\nexport const CURSOR_FLAG_VERTICAL_MAX = 0b1000;\n\n// Misc. shared values\nexport const DEFAULT_POINTER_PRECISION = {\n  coarse: 10,\n  precise: 5\n};\n","import type { Properties } from \"csstype\";\nimport type { RegisteredGroup } from \"../../components/group/types\";\nimport {\n  CURSOR_FLAG_HORIZONTAL_MAX,\n  CURSOR_FLAG_HORIZONTAL_MIN,\n  CURSOR_FLAG_VERTICAL_MAX,\n  CURSOR_FLAG_VERTICAL_MIN\n} from \"../../constants\";\nimport type { InteractionState } from \"../types\";\n\nexport function getCursorStyle({\n  cursorFlags,\n  groups,\n  state\n}: {\n  cursorFlags: number;\n  groups: RegisteredGroup[];\n  state: InteractionState[\"state\"];\n}): Properties[\"cursor\"] | null {\n  let horizontalCount = 0;\n  let verticalCount = 0;\n\n  switch (state) {\n    case \"active\":\n    case \"hover\": {\n      groups.forEach((group) => {\n        if (group.disableCursor) {\n          return;\n        }\n\n        switch (group.orientation) {\n          case \"horizontal\": {\n            horizontalCount++;\n            break;\n          }\n          case \"vertical\": {\n            verticalCount++;\n            break;\n          }\n        }\n      });\n    }\n  }\n\n  if (horizontalCount === 0 && verticalCount === 0) {\n    return null;\n  }\n\n  switch (state) {\n    case \"active\": {\n      const horizontalMin = (cursorFlags & CURSOR_FLAG_HORIZONTAL_MIN) !== 0;\n      const horizontalMax = (cursorFlags & CURSOR_FLAG_HORIZONTAL_MAX) !== 0;\n      const verticalMin = (cursorFlags & CURSOR_FLAG_VERTICAL_MIN) !== 0;\n      const verticalMax = (cursorFlags & CURSOR_FLAG_VERTICAL_MAX) !== 0;\n\n      if (cursorFlags) {\n        if (horizontalMin) {\n          if (verticalMin) {\n            return \"se-resize\";\n          } else if (verticalMax) {\n            return \"ne-resize\";\n          } else {\n            return \"e-resize\";\n          }\n        } else if (horizontalMax) {\n          if (verticalMin) {\n            return \"sw-resize\";\n          } else if (verticalMax) {\n            return \"nw-resize\";\n          } else {\n            return \"w-resize\";\n          }\n        } else if (verticalMin) {\n          return \"s-resize\";\n        } else if (verticalMax) {\n          return \"n-resize\";\n        }\n      }\n      break;\n    }\n  }\n\n  if (horizontalCount > 0 && verticalCount > 0) {\n    return \"move\";\n  } else if (horizontalCount > 0) {\n    return \"ew-resize\";\n  } else {\n    return \"ns-resize\";\n  }\n}\n","import { read } from \"../mutableState\";\nimport { getCursorStyle } from \"./getCursorStyle\";\n\nlet prevStyle: string | undefined = undefined;\nlet styleSheet: CSSStyleSheet | undefined = undefined;\n\nexport function updateCursorStyle() {\n  if (styleSheet === undefined) {\n    styleSheet = new CSSStyleSheet();\n\n    document.adoptedStyleSheets = [styleSheet];\n  }\n\n  const { cursorFlags, interactionState } = read();\n\n  switch (interactionState.state) {\n    case \"active\":\n    case \"hover\": {\n      const cursorStyle = getCursorStyle({\n        cursorFlags,\n        groups: interactionState.hitRegions.map((current) => current.group),\n        state: interactionState.state\n      });\n\n      const nextStyle = `*{cursor: ${cursorStyle} !important; ${interactionState.state === \"active\" ? \"touch-action: none;\" : \"\"} }`;\n      if (prevStyle === nextStyle) {\n        return;\n      }\n\n      prevStyle = nextStyle;\n\n      if (cursorStyle) {\n        if (styleSheet.cssRules.length === 0) {\n          styleSheet.insertRule(nextStyle);\n        } else {\n          styleSheet.replaceSync(nextStyle);\n        }\n      } else if (styleSheet.cssRules.length === 1) {\n        styleSheet.deleteRule(0);\n      }\n      break;\n    }\n    case \"inactive\": {\n      prevStyle = undefined;\n\n      if (styleSheet.cssRules.length === 1) {\n        styleSheet.deleteRule(0);\n      }\n      break;\n    }\n  }\n}\n","export function isArrayEqual(a: number[], b: number[]) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n","import { layoutNumbersEqual } from \"./layoutNumbersEqual\";\n\nexport function compareLayoutNumbers(actual: number, expected: number) {\n  if (layoutNumbersEqual(actual, expected)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\n","import type { PanelConstraints } from \"../../components/panel/types\";\nimport { compareLayoutNumbers } from \"./compareLayoutNumbers\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\n\n// Panel size must be in percentages; pixel values should be pre-converted\nexport function validatePanelSize({\n  panelConstraints,\n  size\n}: {\n  panelConstraints: PanelConstraints;\n  size: number;\n}) {\n  const {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n\n  if (compareLayoutNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (compareLayoutNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n\n  size = Math.min(maxSize, size);\n  size = formatLayoutNumber(size);\n\n  return size;\n}\n","import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { assert } from \"../../utils/assert\";\nimport { isArrayEqual } from \"../../utils/isArrayEqual\";\nimport { compareLayoutNumbers } from \"../utils/compareLayoutNumbers\";\nimport { layoutNumbersEqual } from \"../utils/layoutNumbersEqual\";\nimport { validatePanelSize } from \"../utils/validatePanelSize\";\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function adjustLayoutByDelta({\n  delta,\n  initialLayout: initialLayoutProp,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout: prevLayoutProp,\n  trigger\n}: {\n  delta: number;\n  initialLayout: Layout;\n  panelConstraints: PanelConstraints[];\n  pivotIndices: number[];\n  prevLayout: Layout;\n  trigger: \"imperative-api\" | \"keyboard\" | \"mouse-or-touch\";\n}): Layout {\n  if (layoutNumbersEqual(delta, 0)) {\n    return initialLayoutProp;\n  }\n\n  const initialLayout = Object.values(initialLayoutProp);\n  const prevLayout = Object.values(prevLayoutProp);\n  const nextLayout = [...initialLayout];\n\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the separator should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the separator should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the separator.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(\n          panelConstraints,\n          `Panel constraints not found for index ${index}`\n        );\n\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(\n            prevSize != null,\n            `Previous layout not found for panel index ${index}`\n          );\n\n          if (layoutNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (compareLayoutNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(\n          panelConstraints,\n          `No panel constraints found for index ${index}`\n        );\n\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(\n            prevSize != null,\n            `Previous layout not found for panel index ${index}`\n          );\n\n          if (layoutNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (compareLayoutNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information tooâ€“\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(\n        prevSize != null,\n        `Previous layout not found for panel index ${index}`\n      );\n\n      const maxSafeSize = validatePanelSize({\n        panelConstraints: panelConstraintsArray[index],\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n\n      const prevSize = initialLayout[index];\n      assert(\n        prevSize != null,\n        `Previous layout not found for panel index ${index}`\n      );\n\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = validatePanelSize({\n        panelConstraints: panelConstraintsArray[index],\n        size: unsafeSize\n      });\n\n      if (!layoutNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n\n        nextLayout[index] = safeSize;\n\n        if (\n          deltaApplied\n            .toFixed(3)\n            .localeCompare(Math.abs(delta).toFixed(3), undefined, {\n              numeric: true\n            }) >= 0\n        ) {\n          break;\n        }\n      }\n\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (isArrayEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayoutProp;\n  }\n\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n\n    const prevSize = initialLayout[pivotIndex];\n    assert(\n      prevSize != null,\n      `Previous layout not found for panel index ${pivotIndex}`\n    );\n\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = validatePanelSize({\n      panelConstraints: panelConstraintsArray[pivotIndex],\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!layoutNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(\n          prevSize != null,\n          `Previous layout not found for panel index ${index}`\n        );\n\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = validatePanelSize({\n          panelConstraints: panelConstraintsArray[index],\n          size: unsafeSize\n        });\n\n        if (!layoutNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n\n          nextLayout[index] = safeSize;\n        }\n\n        if (layoutNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = Object.values(nextLayout).reduce(\n    (total, size) => size + total,\n    0\n  );\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  // Allow for a small rounding difference, else e.g. 3 panel layouts may never be considered valid\n  if (!layoutNumbersEqual(totalSize, 100, 0.1)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayoutProp;\n  }\n\n  const prevLayoutKeys = Object.keys(prevLayoutProp);\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout.reduce<Layout>((accumulated, current, index) => {\n    accumulated[prevLayoutKeys[index]] = current;\n    return accumulated;\n  }, {});\n}\n","import type { Layout } from \"../../components/group/types\";\nimport { compareLayoutNumbers } from \"./compareLayoutNumbers\";\n\nexport function layoutsEqual(a: Layout, b: Layout): boolean {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const id in a) {\n    if (compareLayoutNumbers(a[id], b[id]) !== 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Layout, RegisteredGroup } from \"../../components/group/types\";\nimport {\n  CURSOR_FLAG_HORIZONTAL_MAX,\n  CURSOR_FLAG_HORIZONTAL_MIN,\n  CURSOR_FLAG_VERTICAL_MAX,\n  CURSOR_FLAG_VERTICAL_MIN\n} from \"../../constants\";\nimport type { Point } from \"../../types\";\nimport { updateCursorStyle } from \"../cursor/updateCursorStyle\";\nimport type { HitRegion } from \"../dom/calculateHitRegions\";\nimport { update, type MountedGroupMap } from \"../mutableState\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { layoutsEqual } from \"./layoutsEqual\";\n\nexport function updateActiveHitRegions({\n  event,\n  hitRegions,\n  initialLayoutMap,\n  mountedGroups,\n  pointerDownAtPoint\n}: {\n  event: {\n    clientX: number;\n    clientY: number;\n  };\n  hitRegions: HitRegion[];\n  initialLayoutMap: Map<RegisteredGroup, Layout>;\n  mountedGroups: MountedGroupMap;\n  pointerDownAtPoint?: Point;\n}) {\n  let cursorFlags = 0;\n  const nextMountedGroups = new Map(mountedGroups);\n\n  // Note that HitRegions are frozen once a drag has started\n  // Modify the Group layouts for all matching HitRegions though\n  hitRegions.forEach((current) => {\n    const { group, groupSize } = current;\n    const { disableCursor, orientation, panels } = group;\n\n    let deltaAsPercentage = 0;\n    if (pointerDownAtPoint) {\n      if (orientation === \"horizontal\") {\n        deltaAsPercentage =\n          ((event.clientX - pointerDownAtPoint.x) / groupSize) * 100;\n      } else {\n        deltaAsPercentage =\n          ((event.clientY - pointerDownAtPoint.y) / groupSize) * 100;\n      }\n    } else {\n      if (orientation === \"horizontal\") {\n        deltaAsPercentage = event.clientX < 0 ? -100 : 100;\n      } else {\n        deltaAsPercentage = event.clientY < 0 ? -100 : 100;\n      }\n    }\n\n    const initialLayout = initialLayoutMap.get(group);\n\n    const {\n      derivedPanelConstraints,\n      layout: prevLayout,\n      separatorToPanels\n    } = mountedGroups.get(group) ?? {};\n    if (\n      derivedPanelConstraints &&\n      initialLayout &&\n      prevLayout &&\n      separatorToPanels\n    ) {\n      const nextLayout = adjustLayoutByDelta({\n        delta: deltaAsPercentage,\n        initialLayout,\n        panelConstraints: derivedPanelConstraints,\n        pivotIndices: current.panels.map((panel) => panels.indexOf(panel)),\n        prevLayout,\n        trigger: \"mouse-or-touch\"\n      });\n\n      if (layoutsEqual(nextLayout, prevLayout)) {\n        if (deltaAsPercentage !== 0 && !disableCursor) {\n          // An unchanged means the cursor has exceeded the allowed bounds\n          switch (orientation) {\n            case \"horizontal\": {\n              cursorFlags |=\n                deltaAsPercentage < 0\n                  ? CURSOR_FLAG_HORIZONTAL_MIN\n                  : CURSOR_FLAG_HORIZONTAL_MAX;\n              break;\n            }\n            case \"vertical\": {\n              cursorFlags |=\n                deltaAsPercentage < 0\n                  ? CURSOR_FLAG_VERTICAL_MIN\n                  : CURSOR_FLAG_VERTICAL_MAX;\n              break;\n            }\n          }\n        }\n      } else {\n        nextMountedGroups.set(current.group, {\n          derivedPanelConstraints: derivedPanelConstraints,\n          layout: nextLayout,\n          separatorToPanels\n        });\n\n        // Save the most recent layout for this group of panels in-memory\n        // so that layouts will be remembered between different sets of conditionally rendered panels\n        const panelIdsKey = current.group.panels.map(({ id }) => id).join(\",\");\n        current.group.inMemoryLayouts[panelIdsKey] = nextLayout;\n      }\n    }\n  });\n\n  update({\n    cursorFlags,\n    mountedGroups: nextMountedGroups\n  });\n\n  updateCursorStyle();\n}\n","import { read } from \"../mutableState\";\nimport { updateActiveHitRegions } from \"../utils/updateActiveHitRegion\";\n\nexport function onGroupPointerLeave(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  } else if (event.relatedTarget !== null) {\n    return;\n  } else if (event.clientX === 0 && event.clientY === 0) {\n    // Edge case iOS Safari bug; coordinates are seemingly nonsensical which would break the drag event\n    return;\n  }\n\n  const { interactionState, mountedGroups } = read();\n\n  // The \"pointerleave\" event is not reliably triggered when the pointer exits a window or iframe\n  // To account for this, we listen for \"pointerleave\" events on the Group element itself\n  switch (interactionState.state) {\n    case \"active\": {\n      interactionState.hitRegions.forEach((hitRegion) => {\n        if (event.currentTarget === hitRegion.group.element) {\n          updateActiveHitRegions({\n            event,\n            hitRegions: interactionState.hitRegions,\n            initialLayoutMap: interactionState.initialLayoutMap,\n            mountedGroups\n          });\n        }\n      });\n    }\n  }\n}\n","import { assert } from \"../../utils/assert\";\nimport { read } from \"../mutableState\";\n\nexport function findSeparatorGroup(separatorElement: HTMLElement) {\n  const groupElement = separatorElement.parentElement;\n  assert(groupElement, \"Parent group element not found\");\n\n  const { mountedGroups } = read();\n\n  for (const [group] of mountedGroups) {\n    if (group.element === groupElement) {\n      return group;\n    }\n  }\n\n  throw Error(\"Could not find parent Group for separator element\");\n}\n","import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { assert } from \"../../utils/assert\";\nimport { layoutNumbersEqual } from \"./layoutNumbersEqual\";\nimport { validatePanelSize } from \"./validatePanelSize\";\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function validatePanelGroupLayout({\n  layout,\n  panelConstraints\n}: {\n  layout: Layout;\n  panelConstraints: PanelConstraints[];\n}): Layout {\n  const prevLayout = Object.values(layout);\n  const nextLayout = [...prevLayout];\n\n  const nextLayoutTotalSize = nextLayout.reduce(\n    (accumulated, current) => accumulated + current,\n    0\n  );\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(\n      `Invalid ${panelConstraints.length} panel layout: ${nextLayout\n        .map((size) => `${size}%`)\n        .join(\", \")}`\n    );\n  } else if (\n    !layoutNumbersEqual(nextLayoutTotalSize, 100) &&\n    nextLayout.length > 0\n  ) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n\n    const safeSize = validatePanelSize({\n      panelConstraints: panelConstraints[index],\n      size: unsafeSize\n    });\n\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!layoutNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = validatePanelSize({\n        panelConstraints: panelConstraints[index],\n        size: unsafeSize\n      });\n\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (layoutNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n\n  const prevLayoutKeys = Object.keys(layout);\n\n  return nextLayout.reduce<Layout>((accumulated, current, index) => {\n    accumulated[prevLayoutKeys[index]] = current;\n    return accumulated;\n  }, {});\n}\n","import type {\n  GroupImperativeHandle,\n  Layout\n} from \"../../components/group/types\";\nimport { read, update } from \"../mutableState\";\nimport { layoutsEqual } from \"./layoutsEqual\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function getImperativeGroupMethods({\n  groupId\n}: {\n  groupId: string;\n}): GroupImperativeHandle {\n  const find = () => {\n    const { mountedGroups } = read();\n    for (const [group, value] of mountedGroups) {\n      if (group.id === groupId) {\n        return { group, ...value };\n      }\n    }\n\n    throw Error(`Group ${groupId} not found`);\n  };\n\n  return {\n    getLayout() {\n      const { layout } = find();\n\n      return layout;\n    },\n    setLayout(unsafeLayout: Layout) {\n      const {\n        derivedPanelConstraints,\n        group,\n        layout: prevLayout,\n        separatorToPanels\n      } = find();\n\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: derivedPanelConstraints\n      });\n\n      if (!layoutsEqual(prevLayout, nextLayout)) {\n        update((prevState) => ({\n          mountedGroups: new Map(prevState.mountedGroups).set(group, {\n            derivedPanelConstraints,\n            layout: nextLayout,\n            separatorToPanels\n          })\n        }));\n      }\n\n      return nextLayout;\n    }\n  };\n}\n","import type { RegisteredGroup } from \"../../components/group/types\";\nimport { assert } from \"../../utils/assert\";\nimport { read } from \"../mutableState\";\n\nexport function getMountedGroup(group: RegisteredGroup) {\n  const { mountedGroups } = read();\n\n  const mountedGroup = mountedGroups.get(group);\n  assert(mountedGroup, `Mounted Group ${group.id} not found`);\n\n  return mountedGroup;\n}\n","import { assert } from \"../../utils/assert\";\nimport { update } from \"../mutableState\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { findSeparatorGroup } from \"./findSeparatorGroup\";\nimport { getImperativeGroupMethods } from \"./getImperativeGroupMethods\";\nimport { getMountedGroup } from \"./getMountedGroup\";\nimport { layoutsEqual } from \"./layoutsEqual\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function adjustLayoutForSeparator(\n  separatorElement: HTMLElement,\n  delta: number\n) {\n  const group = findSeparatorGroup(separatorElement);\n  const mountedGroup = getMountedGroup(group);\n\n  const separator = group.separators.find(\n    (current) => current.element === separatorElement\n  );\n  assert(separator, \"Matching separator not found\");\n\n  const panels = mountedGroup.separatorToPanels.get(separator);\n  assert(panels, \"Matching panels not found\");\n\n  const pivotIndices = panels.map((panel) => group.panels.indexOf(panel));\n\n  const groupAPI = getImperativeGroupMethods({ groupId: group.id });\n  const prevLayout = groupAPI.getLayout();\n\n  const unsafeLayout = adjustLayoutByDelta({\n    delta,\n    initialLayout: prevLayout,\n    panelConstraints: mountedGroup.derivedPanelConstraints,\n    pivotIndices,\n    prevLayout,\n    trigger: \"keyboard\"\n  });\n  const nextLayout = validatePanelGroupLayout({\n    layout: unsafeLayout,\n    panelConstraints: mountedGroup.derivedPanelConstraints\n  });\n\n  if (!layoutsEqual(prevLayout, nextLayout)) {\n    update((prevState) => ({\n      mountedGroups: new Map(prevState.mountedGroups).set(group, {\n        derivedPanelConstraints: mountedGroup.derivedPanelConstraints,\n        layout: nextLayout,\n        separatorToPanels: mountedGroup.separatorToPanels\n      })\n    }));\n  }\n}\n","import { assert } from \"../../utils/assert\";\nimport { adjustLayoutForSeparator } from \"../utils/adjustLayoutForSeparator\";\nimport { findSeparatorGroup } from \"../utils/findSeparatorGroup\";\nimport { getMountedGroup } from \"../utils/getMountedGroup\";\n\nexport function onWindowKeyDown(event: KeyboardEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const separatorElement = event.currentTarget as HTMLElement;\n\n  const group = findSeparatorGroup(separatorElement);\n  if (group.disabled) {\n    return;\n  }\n\n  switch (event.key) {\n    case \"ArrowDown\": {\n      event.preventDefault();\n\n      if (group.orientation === \"vertical\") {\n        adjustLayoutForSeparator(separatorElement, 5);\n      }\n      break;\n    }\n    case \"ArrowLeft\": {\n      event.preventDefault();\n\n      if (group.orientation === \"horizontal\") {\n        adjustLayoutForSeparator(separatorElement, -5);\n      }\n      break;\n    }\n    case \"ArrowRight\": {\n      event.preventDefault();\n\n      if (group.orientation === \"horizontal\") {\n        adjustLayoutForSeparator(separatorElement, 5);\n      }\n      break;\n    }\n    case \"ArrowUp\": {\n      event.preventDefault();\n\n      if (group.orientation === \"vertical\") {\n        adjustLayoutForSeparator(separatorElement, -5);\n      }\n      break;\n    }\n    case \"End\": {\n      event.preventDefault();\n\n      // Moves splitter to the position that gives the primary pane its largest allowed size.\n      // This may completely collapse the secondary pane.\n\n      adjustLayoutForSeparator(separatorElement, 100);\n      break;\n    }\n    case \"Enter\": {\n      event.preventDefault();\n\n      // If the primary pane is not collapsed, collapses the pane.\n      // If the pane is collapsed, restores the splitter to its previous position.\n\n      const group = findSeparatorGroup(separatorElement);\n      const { derivedPanelConstraints, layout, separatorToPanels } =\n        getMountedGroup(group);\n\n      const separator = group.separators.find(\n        (current) => current.element === separatorElement\n      );\n      assert(separator, \"Matching separator not found\");\n\n      const panels = separatorToPanels.get(separator);\n      assert(panels, \"Matching panels not found\");\n\n      const primaryPanel = panels[0];\n      const constraints = derivedPanelConstraints.find(\n        (current) => current.panelId === primaryPanel.id\n      );\n      assert(constraints, \"Panel metadata not found\");\n\n      if (constraints.collapsible) {\n        const prevSize = layout[primaryPanel.id];\n\n        const nextSize =\n          constraints.collapsedSize === prevSize\n            ? (group.inMemoryLastExpandedPanelSizes[primaryPanel.id] ??\n              constraints.minSize)\n            : constraints.collapsedSize;\n\n        adjustLayoutForSeparator(separatorElement, nextSize - prevSize);\n      }\n      break;\n    }\n    case \"F6\": {\n      event.preventDefault();\n\n      // Cycle through window panes.\n\n      const group = findSeparatorGroup(separatorElement);\n\n      const separatorElements = group.separators.map(\n        (separator) => separator.element\n      );\n\n      const index = Array.from(separatorElements).findIndex(\n        (current) => current === event.currentTarget\n      );\n      assert(index !== null, \"Index not found\");\n\n      const nextIndex = event.shiftKey\n        ? index > 0\n          ? index - 1\n          : separatorElements.length - 1\n        : index + 1 < separatorElements.length\n          ? index + 1\n          : 0;\n\n      const nextSeparatorElement = separatorElements[nextIndex] as HTMLElement;\n      nextSeparatorElement.focus();\n      break;\n    }\n    case \"Home\": {\n      event.preventDefault();\n\n      // Moves splitter to the position that gives the primary pane its smallest allowed size.\n      // This may completely collapse the primary pane.\n\n      adjustLayoutForSeparator(separatorElement, -100);\n      break;\n    }\n  }\n}\n","import type { Point } from \"../../types\";\n\nexport function getDistanceBetweenPointAndRect(\n  point: Point,\n  rect: DOMRectReadOnly\n) {\n  return {\n    x:\n      point.x >= rect.left && point.x <= rect.right\n        ? 0\n        : Math.min(\n            Math.abs(point.x - rect.left),\n            Math.abs(point.x - rect.right)\n          ),\n    y:\n      point.y >= rect.top && point.y <= rect.bottom\n        ? 0\n        : Math.min(\n            Math.abs(point.y - rect.top),\n            Math.abs(point.y - rect.bottom)\n          )\n  };\n}\n","import type { Orientation } from \"../../components/group/types\";\nimport type { Point } from \"../../types\";\nimport type { HitRegion } from \"../dom/calculateHitRegions\";\nimport { getDistanceBetweenPointAndRect } from \"./getDistanceBetweenPointAndRect\";\n\nexport function findClosetHitRegion(\n  orientation: Orientation,\n  hitRegions: HitRegion[],\n  point: Point\n) {\n  let closestHitRegion: HitRegion | undefined = undefined;\n  let minDistance = {\n    x: Infinity,\n    y: Infinity\n  };\n\n  for (const hitRegion of hitRegions) {\n    const data = getDistanceBetweenPointAndRect(point, hitRegion.rect);\n    switch (orientation) {\n      case \"horizontal\": {\n        if (data.x <= minDistance.x) {\n          closestHitRegion = hitRegion;\n          minDistance = data;\n        }\n        break;\n      }\n      case \"vertical\": {\n        if (data.y <= minDistance.y) {\n          closestHitRegion = hitRegion;\n          minDistance = data;\n        }\n        break;\n      }\n    }\n  }\n\n  return closestHitRegion\n    ? {\n        distance: minDistance,\n        hitRegion: closestHitRegion\n      }\n    : undefined;\n}\n","let cached: boolean | undefined = undefined;\n\nexport function isCoarsePointer(): boolean {\n  if (cached === undefined) {\n    if (typeof matchMedia === \"function\") {\n      cached = !!matchMedia(\"(pointer:coarse)\").matches;\n    } else {\n      cached = false;\n    }\n  }\n\n  return cached;\n}\n","import { DEFAULT_POINTER_PRECISION } from \"../../constants\";\nimport type { MountedGroupMap } from \"../mutableState\";\nimport {\n  calculateHitRegions,\n  type HitRegion\n} from \"../dom/calculateHitRegions\";\nimport { findClosetHitRegion } from \"./findClosetHitRegion\";\nimport { isCoarsePointer } from \"./isCoarsePointer\";\n\nexport function findMatchingHitRegions(\n  event: PointerEvent,\n  mountedGroups: MountedGroupMap\n): HitRegion[] {\n  const matchingHitRegions: HitRegion[] = [];\n\n  mountedGroups.forEach((_, groupData) => {\n    if (groupData.disabled) {\n      return;\n    }\n\n    const maxDistance = isCoarsePointer()\n      ? DEFAULT_POINTER_PRECISION.coarse\n      : DEFAULT_POINTER_PRECISION.precise;\n\n    const hitRegions = calculateHitRegions(groupData);\n    const match = findClosetHitRegion(groupData.orientation, hitRegions, {\n      x: event.clientX,\n      y: event.clientY\n    });\n\n    if (\n      match &&\n      match.distance.x <= maxDistance &&\n      match.distance.y <= maxDistance\n    ) {\n      matchingHitRegions.push(match.hitRegion);\n    }\n  });\n\n  return matchingHitRegions;\n}\n","import type { Layout, RegisteredGroup } from \"../../components/group/types\";\nimport type { RegisteredPanel } from \"../../components/panel/types\";\nimport type { RegisteredSeparator } from \"../../components/separator/types\";\nimport { read, update } from \"../mutableState\";\nimport { findMatchingHitRegions } from \"../utils/findMatchingHitRegions\";\n\nexport function onWindowPointerDown(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const { mountedGroups } = read();\n\n  const hitRegions = findMatchingHitRegions(event, mountedGroups);\n\n  const groups = new Set<RegisteredGroup>();\n  const panels = new Set<RegisteredPanel>();\n  const separators = new Set<RegisteredSeparator>();\n  const initialLayoutMap = new Map<RegisteredGroup, Layout>();\n\n  let didChangeFocus = false;\n\n  hitRegions.forEach((current) => {\n    groups.add(current.group);\n    current.panels.forEach((panel) => {\n      panels.add(panel);\n    });\n    if (current.separator) {\n      separators.add(current.separator);\n\n      if (!didChangeFocus) {\n        didChangeFocus = true;\n\n        current.separator.element.focus();\n      }\n    }\n\n    const match = mountedGroups.get(current.group);\n    if (match) {\n      initialLayoutMap.set(current.group, match.layout);\n    }\n  });\n\n  update({\n    interactionState: {\n      hitRegions,\n      initialLayoutMap,\n      pointerDownAtPoint: { x: event.clientX, y: event.clientY },\n      state: \"active\"\n    }\n  });\n\n  if (hitRegions.length) {\n    event.preventDefault();\n  }\n}\n","import { updateCursorStyle } from \"../cursor/updateCursorStyle\";\nimport { read, update } from \"../mutableState\";\nimport { findMatchingHitRegions } from \"../utils/findMatchingHitRegions\";\nimport { updateActiveHitRegions } from \"../utils/updateActiveHitRegion\";\n\nexport function onWindowPointerMove(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const { interactionState, mountedGroups } = read();\n\n  switch (interactionState.state) {\n    case \"active\": {\n      // Edge case (see #340)\n      // Detect when the pointer has been released outside an iframe on a different domain\n      if (\n        // Skip this check for \"pointerleave\" events, else Firefox triggers a false positive (see #514)\n        event.type !== \"pointerleave\" &&\n        event.buttons === 0\n      ) {\n        update((prevState) =>\n          prevState.interactionState.state === \"inactive\"\n            ? prevState\n            : {\n                cursorFlags: 0,\n                interactionState: {\n                  state: \"inactive\"\n                }\n              }\n        );\n\n        return;\n      }\n\n      updateActiveHitRegions({\n        event,\n        hitRegions: interactionState.hitRegions,\n        initialLayoutMap: interactionState.initialLayoutMap,\n        mountedGroups,\n        pointerDownAtPoint: interactionState.pointerDownAtPoint\n      });\n      break;\n    }\n    default: {\n      // Update HitRegions if a drag has not been started\n      const hitRegions = findMatchingHitRegions(event, mountedGroups);\n\n      if (hitRegions.length === 0) {\n        if (interactionState.state !== \"inactive\") {\n          update({\n            interactionState: { state: \"inactive\" }\n          });\n        }\n      } else {\n        update({\n          interactionState: {\n            hitRegions,\n            state: \"hover\"\n          }\n        });\n      }\n\n      updateCursorStyle();\n      break;\n    }\n  }\n}\n","import { updateCursorStyle } from \"../cursor/updateCursorStyle\";\nimport { read, update } from \"../mutableState\";\n\nexport function onWindowPointerUp(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  event.preventDefault();\n\n  const { interactionState } = read();\n\n  switch (interactionState.state) {\n    case \"active\": {\n      update({\n        cursorFlags: 0,\n        interactionState: {\n          state: \"inactive\"\n        }\n      });\n\n      updateCursorStyle();\n    }\n  }\n}\n","import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\n\nexport function calculateDefaultLayout(\n  derivedPanelConstraints: PanelConstraints[]\n): Layout {\n  let explicitCount = 0;\n  let total = 0;\n\n  const layout: Layout = {};\n\n  for (const current of derivedPanelConstraints) {\n    if (current.defaultSize !== undefined) {\n      explicitCount++;\n\n      const size = formatLayoutNumber(current.defaultSize);\n\n      total += size;\n      layout[current.panelId] = size;\n    } else {\n      // @ts-expect-error Add panel keys in order to simplify traversal elsewhere; we'll fill them in in the loop below\n      layout[current.panelId] = undefined;\n    }\n  }\n\n  const remainingPanelCount = derivedPanelConstraints.length - explicitCount;\n  if (remainingPanelCount !== 0) {\n    const size = formatLayoutNumber((100 - total) / remainingPanelCount);\n\n    for (const current of derivedPanelConstraints) {\n      if (current.defaultSize === undefined) {\n        layout[current.panelId] = size;\n      }\n    }\n  }\n\n  return layout;\n}\n","import type { RegisteredGroup } from \"../../components/group/types\";\nimport { calculateAvailableGroupSize } from \"../dom/calculateAvailableGroupSize\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\n\nexport function notifyPanelOnResize(\n  group: RegisteredGroup,\n  element: HTMLElement,\n  borderBoxSize: readonly ResizeObserverSize[]\n) {\n  const resizeObserverSize = borderBoxSize[0];\n  if (!resizeObserverSize) {\n    return;\n  }\n\n  const panel = group.panels.find((current) => current.element === element);\n  if (!panel || !panel.onResize) {\n    return;\n  }\n\n  const groupSize = calculateAvailableGroupSize({ group });\n\n  panel.onResize(\n    {\n      asPercentage: formatLayoutNumber(\n        (resizeObserverSize.inlineSize / groupSize) * 100\n      ),\n      inPixels: resizeObserverSize.inlineSize\n    },\n    panel.id\n  );\n}\n","import type { Layout, RegisteredGroup } from \"../components/group/types\";\nimport { assert } from \"../utils/assert\";\nimport { calculateHitRegions } from \"./dom/calculateHitRegions\";\nimport { calculatePanelConstraints } from \"./dom/calculatePanelConstraints\";\nimport { onGroupPointerLeave } from \"./event-handlers/onGroupPointerLeave\";\nimport { onWindowKeyDown } from \"./event-handlers/onWindowKeyDown\";\nimport { onWindowPointerDown } from \"./event-handlers/onWindowPointerDown\";\nimport { onWindowPointerMove } from \"./event-handlers/onWindowPointerMove\";\nimport { onWindowPointerUp } from \"./event-handlers/onWindowPointerUp\";\nimport { update } from \"./mutableState\";\nimport { calculateDefaultLayout } from \"./utils/calculateDefaultLayout\";\nimport { notifyPanelOnResize } from \"./utils/notifyPanelOnResize\";\nimport { validatePanelGroupLayout } from \"./utils/validatePanelGroupLayout\";\n\nexport function mountGroup(group: RegisteredGroup) {\n  let isMounted = true;\n\n  // Invariants\n  assert(\n    group.separators.length === 0 ||\n      group.separators.length < group.panels.length,\n    \"Invalid Group configuration; too many Separator components\"\n  );\n\n  const panelIds = new Set<string>();\n  const separatorIds = new Set<string>();\n\n  // Add Panels with onResize callbacks to ResizeObserver\n  // Add Group to ResizeObserver also in order to sync % based constraints\n  const resizeObserver = new ResizeObserver((entries) => {\n    for (const entry of entries) {\n      const { borderBoxSize, target } = entry;\n      if (target === group.element) {\n        if (isMounted) {\n          update((prevState) => {\n            const match = prevState.mountedGroups.get(group);\n            if (match) {\n              // Update non-percentage based constraints\n              const nextDerivedPanelConstraints =\n                calculatePanelConstraints(group);\n\n              // Revalidate layout in case constraints have changed\n              const prevLayout = match.layout;\n              const nextLayout = validatePanelGroupLayout({\n                layout: prevLayout,\n                panelConstraints: nextDerivedPanelConstraints\n              });\n\n              return {\n                mountedGroups: new Map(prevState.mountedGroups).set(group, {\n                  derivedPanelConstraints: nextDerivedPanelConstraints,\n                  layout: nextLayout,\n                  separatorToPanels: match.separatorToPanels\n                })\n              };\n            }\n            return prevState;\n          });\n        }\n      } else {\n        notifyPanelOnResize(group, target as HTMLElement, borderBoxSize);\n      }\n    }\n  });\n  resizeObserver.observe(group.element);\n  group.panels.forEach((panel) => {\n    assert(\n      !panelIds.has(panel.id),\n      `Panel ids must be unique; id \"${panel.id}\" was used more than once`\n    );\n\n    panelIds.add(panel.id);\n\n    if (panel.onResize) {\n      resizeObserver.observe(panel.element);\n    }\n  });\n\n  // Calculate initial layout for the new Panel configuration\n  const derivedPanelConstraints = calculatePanelConstraints(group);\n  const panelIdsKey = group.panels.map(({ id }) => id).join(\",\");\n  const defaultLayoutUnsafe: Layout =\n    group.inMemoryLayouts[panelIdsKey] ??\n    group.defaultLayout ??\n    calculateDefaultLayout(derivedPanelConstraints);\n  const defaultLayoutSafe = validatePanelGroupLayout({\n    layout: defaultLayoutUnsafe,\n    panelConstraints: derivedPanelConstraints\n  });\n\n  const hitRegions = calculateHitRegions(group);\n\n  const nextState = update((prevState) => ({\n    mountedGroups: new Map(prevState.mountedGroups).set(group, {\n      derivedPanelConstraints,\n      layout: defaultLayoutSafe,\n      separatorToPanels: new Map(\n        hitRegions\n          .filter((hitRegion) => hitRegion.separator)\n          .map((hitRegion) => [hitRegion.separator!, hitRegion.panels])\n      )\n    })\n  }));\n\n  // The \"pointerleave\" event is not reliably triggered when the pointer exits a window or iframe\n  // To account for this, we listen for \"pointerleave\" events on the Group element itself\n  group.element.addEventListener(\"pointerleave\", onGroupPointerLeave);\n\n  group.separators.forEach((separator) => {\n    assert(\n      !separatorIds.has(separator.id),\n      `Separator ids must be unique; id \"${separator.id}\" was used more than once`\n    );\n\n    separatorIds.add(separator.id);\n\n    separator.element.addEventListener(\"keydown\", onWindowKeyDown);\n  });\n\n  // If this is the first group to be mounted, initialize event handlers\n  if (nextState.mountedGroups.size === 1) {\n    window.addEventListener(\"pointerdown\", onWindowPointerDown);\n    window.addEventListener(\"pointermove\", onWindowPointerMove);\n    window.addEventListener(\"pointerup\", onWindowPointerUp);\n  }\n\n  return function unmountGroup() {\n    isMounted = false;\n\n    const nextState = update((prevState) => {\n      const mountedGroups = new Map(prevState.mountedGroups);\n      mountedGroups.delete(group);\n\n      return { mountedGroups };\n    });\n\n    group.element.removeEventListener(\"pointerleave\", onGroupPointerLeave);\n\n    group.separators.forEach((separator) => {\n      separator.element.removeEventListener(\"keydown\", onWindowKeyDown);\n    });\n\n    // If this was the last group to be mounted, tear down event handlers\n    if (nextState.mountedGroups.size === 0) {\n      window.removeEventListener(\"pointerdown\", onWindowPointerDown);\n      window.removeEventListener(\"pointermove\", onWindowPointerMove);\n      window.removeEventListener(\"pointerup\", onWindowPointerUp);\n    }\n\n    resizeObserver.disconnect();\n  };\n}\n","import { useId as useIdReact } from \"react\";\n\nexport function useId(stableId: number | string | undefined) {\n  const dynamicId = useIdReact();\n\n  return `${stableId ?? dynamicId}`;\n}\n","import { useEffect, useLayoutEffect } from \"react\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import { useCallback, useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\n// Forked from useEventCallback (usehooks-ts)\nexport function useStableCallback<Return>(fn: () => Return): () => Return;\nexport function useStableCallback<Args, Return>(\n  fn: (args: Args) => Return\n): (args: Args) => Return;\nexport function useStableCallback<Args, Return>(\n  fn: (args: Args) => Return\n): (args: Args) => Return {\n  const ref = useRef<typeof fn>(fn);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback((args: Args) => ref.current?.(args), [ref]) as (\n    args: Args\n  ) => Return;\n}\n","import { type Ref } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ntype PossibleRef<Type> = Ref<Type> | undefined;\n\nexport function useMergedRefs<Type>(...refs: PossibleRef<Type>[]) {\n  return useStableCallback((value: Type | null) => {\n    refs.forEach((ref) => {\n      if (ref) {\n        switch (typeof ref) {\n          case \"function\": {\n            ref(value);\n            break;\n          }\n          case \"object\": {\n            ref.current = value;\n            break;\n          }\n        }\n      }\n    });\n  });\n}\n","export const POINTER_EVENTS_CSS_PROPERTY_NAME =\n  \"--react-resizable-panels--panel--pointer-events\";\n","export function getPanelSizeCssPropertyName(groupId: string, panelId: string) {\n  const groupIdEscaped = groupId.replace(/[^a-zA-Z0-9\\-_]/g, \"\");\n  const panelIdEscaped = panelId.replace(/[^a-zA-Z0-9\\-_]/g, \"\");\n\n  return `--react-resizable-panels--${groupIdEscaped}--${panelIdEscaped}`;\n}\n","import { createContext } from \"react\";\nimport type { GroupContextType } from \"./types\";\n\nexport const GroupContext = createContext<GroupContextType | null>(null);\n","import { useImperativeHandle, useRef, type Ref } from \"react\";\nimport { IDENTITY_FUNCTION } from \"../../constants\";\nimport { getImperativeGroupMethods } from \"../../global/utils/getImperativeGroupMethods\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport type { GroupImperativeHandle } from \"./types\";\n\nexport function useGroupImperativeHandle(\n  groupId: string,\n  groupRef: Ref<GroupImperativeHandle> | undefined\n) {\n  const imperativeGroupRef = useRef<GroupImperativeHandle>({\n    getLayout: () => ({}),\n    setLayout: IDENTITY_FUNCTION\n  });\n\n  useImperativeHandle(groupRef, () => imperativeGroupRef.current, []);\n\n  useIsomorphicLayoutEffect(() => {\n    Object.assign(\n      imperativeGroupRef.current,\n      getImperativeGroupMethods({ groupId })\n    );\n  });\n}\n","\"use client\";\nimport { useMemo, useRef, useState } from \"react\";\nimport { mountGroup } from \"../../global/mountGroup\";\nimport { eventEmitter, read } from \"../../global/mutableState\";\nimport { layoutsEqual } from \"../../global/utils/layoutsEqual\";\nimport { useId } from \"../../hooks/useId\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMergedRefs } from \"../../hooks/useMergedRefs\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { POINTER_EVENTS_CSS_PROPERTY_NAME } from \"../panel/constants\";\nimport type { RegisteredPanel } from \"../panel/types\";\nimport type { RegisteredSeparator } from \"../separator/types\";\nimport { getPanelSizeCssPropertyName } from \"./getPanelSizeCssPropertyName\";\nimport { GroupContext } from \"./GroupContext\";\nimport { sortByElementOffset } from \"./sortByElementOffset\";\nimport type { GroupProps, Layout, RegisteredGroup } from \"./types\";\nimport { useGroupImperativeHandle } from \"./useGroupImperativeHandle\";\n\n/**\n * A Group wraps a set of resizable Panel components.\n * Group content can be resized _horizontally_ or _vertically_.\n *\n * Group elements always include the following attributes:\n *\n * ```html\n * <div data-group data-testid=\"group-id-prop\" id=\"group-id-prop\">\n * ```\n *\n * â„¹ï¸ [Test id](https://testing-library.com/docs/queries/bytestid/) can be used to narrow selection when unit testing.\n */\nexport function Group({\n  children,\n  className,\n  defaultLayout,\n  disableCursor,\n  disabled,\n  elementRef,\n  groupRef,\n  id: idProp,\n  onLayoutChange: onLayoutChangeUnstable,\n  orientation = \"horizontal\",\n  style,\n  ...rest\n}: GroupProps) {\n  const prevLayoutRef = useRef<Layout>({});\n\n  const onLayoutChangeStable = useStableCallback((layout: Layout) => {\n    if (layoutsEqual(prevLayoutRef.current, layout)) {\n      // Memoize callback\n      return;\n    }\n\n    prevLayoutRef.current = layout;\n    onLayoutChangeUnstable?.(layout);\n  });\n\n  const id = useId(idProp);\n\n  const [dragActive, setDragActive] = useState(false);\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n  const [layout, setLayout] = useState<Layout>(defaultLayout ?? {});\n  const [panels, setPanels] = useState<RegisteredPanel[]>([]);\n  const [separators, setSeparators] = useState<RegisteredSeparator[]>([]);\n\n  const inMemoryLastExpandedPanelSizesRef = useRef<{\n    [panelIds: string]: number;\n  }>({});\n  const inMemoryLayoutsRef = useRef<{\n    [panelIds: string]: Layout;\n  }>({});\n\n  const mergedRef = useMergedRefs(setElement, elementRef);\n\n  useGroupImperativeHandle(id, groupRef);\n\n  const context = useMemo(\n    () => ({\n      id,\n      orientation,\n      registerPanel: (panel: RegisteredPanel) => {\n        setPanels((prev) => sortByElementOffset(orientation, [...prev, panel]));\n        return () => {\n          setPanels((prev) => prev.filter((current) => current !== panel));\n        };\n      },\n      registerSeparator: (separator: RegisteredSeparator) => {\n        setSeparators((prev) =>\n          sortByElementOffset(orientation, [...prev, separator])\n        );\n        return () => {\n          setSeparators((prev) =>\n            prev.filter((current) => current !== separator)\n          );\n        };\n      }\n    }),\n    [id, orientation]\n  );\n\n  // Register Group and child Panels/Separators with global state\n  // Listen to global state for drag state related to this Group\n  useIsomorphicLayoutEffect(() => {\n    if (element !== null && panels.length > 0) {\n      const group: RegisteredGroup = {\n        defaultLayout,\n        disableCursor: !!disableCursor,\n        disabled: !!disabled,\n        element,\n        id,\n        inMemoryLastExpandedPanelSizes:\n          inMemoryLastExpandedPanelSizesRef.current,\n        inMemoryLayouts: inMemoryLayoutsRef.current,\n        orientation,\n        panels,\n        separators\n      };\n\n      const unmountGroup = mountGroup(group);\n\n      const globalState = read();\n      const match = globalState.mountedGroups.get(group);\n      if (match) {\n        setLayout(match.layout);\n        onLayoutChangeStable?.(match.layout);\n      }\n\n      const removeInteractionStateChangeListener = eventEmitter.addListener(\n        \"interactionStateChange\",\n        (interactionState) => {\n          switch (interactionState.state) {\n            case \"active\": {\n              setDragActive(\n                interactionState.hitRegions.some(\n                  (current) => current.group === group\n                )\n              );\n              break;\n            }\n            default: {\n              setDragActive(false);\n              break;\n            }\n          }\n        }\n      );\n\n      const removeMountedGroupsChangeEventListener = eventEmitter.addListener(\n        \"mountedGroupsChange\",\n        (mountedGroups) => {\n          const match = mountedGroups.get(group);\n          if (match && match.derivedPanelConstraints.length > 0) {\n            setLayout(match.layout);\n            onLayoutChangeStable?.(match.layout);\n          }\n        }\n      );\n\n      return () => {\n        unmountGroup();\n        removeInteractionStateChangeListener();\n        removeMountedGroupsChangeEventListener();\n      };\n    }\n  }, [\n    defaultLayout,\n    disableCursor,\n    disabled,\n    element,\n    id,\n    onLayoutChangeStable,\n    orientation,\n    panels,\n    separators\n  ]);\n\n  // Panel layouts and Group dragging state are shared via CSS variables\n  const cssVariables: { [key: string]: number | string | undefined } = {\n    [POINTER_EVENTS_CSS_PROPERTY_NAME]: dragActive ? \"none\" : undefined\n  };\n  for (const panelId in layout) {\n    const propertyName = getPanelSizeCssPropertyName(id, panelId);\n    const flexGrow = layout[panelId];\n    cssVariables[propertyName] = flexGrow;\n  }\n\n  return (\n    <GroupContext.Provider value={context}>\n      <div\n        {...rest}\n        aria-orientation={orientation}\n        className={className}\n        data-group\n        data-testid={id}\n        id={id}\n        ref={mergedRef}\n        style={{\n          ...style,\n          ...cssVariables,\n          display: \"flex\",\n          flexDirection: orientation === \"horizontal\" ? \"row\" : \"column\",\n          flexWrap: \"nowrap\"\n        }}\n      >\n        {children}\n      </div>\n    </GroupContext.Provider>\n  );\n}\n","export function getStorageKey(id: string): string {\n  return `react-resizable-panels:${id}`;\n}\n","import type { Layout, LayoutStorage } from \"../types\";\nimport { getStorageKey } from \"./getStorageKey\";\n\nexport function saveGroupLayout({\n  id,\n  layout,\n  storage\n}: {\n  id: string;\n  layout: Layout;\n  storage: LayoutStorage;\n}) {\n  try {\n    const storageKey = getStorageKey(id);\n\n    storage.setItem(storageKey, JSON.stringify(layout));\n  } catch (error) {\n    console.error(error);\n  }\n}\n","import { useCallback, useMemo, useSyncExternalStore } from \"react\";\nimport { getStorageKey } from \"./auto-save/getStorageKey\";\nimport { saveGroupLayout } from \"./auto-save/saveGroupLayout\";\nimport type { Layout, LayoutStorage, OnGroupLayoutChange } from \"./types\";\n\nexport function useDefaultLayout({\n  groupId,\n  storage\n}: {\n  groupId: string;\n  storage: LayoutStorage;\n}) {\n  // In the event that a client-only storage API is provided,\n  // useSyncExternalStore prevents server/client hydration mismatch warning\n  // This is not ideal; if possible a server-friendly storage API should be used\n  const defaultLayoutString = useSyncExternalStore(\n    subscribe,\n    () => storage.getItem(getStorageKey(groupId)),\n    () => storage.getItem(getStorageKey(groupId))\n  );\n\n  const defaultLayout = useMemo(\n    () =>\n      defaultLayoutString\n        ? (JSON.parse(defaultLayoutString) as Layout)\n        : undefined,\n    [defaultLayoutString]\n  );\n\n  const onLayoutChange = useCallback<NonNullable<OnGroupLayoutChange>>(\n    (layout) =>\n      saveGroupLayout({\n        id: groupId,\n        layout,\n        storage\n      }),\n    [groupId, storage]\n  );\n\n  return {\n    defaultLayout,\n    onLayoutChange\n  };\n}\n\nfunction subscribe() {\n  return function unsubscribe() {};\n}\n","import { useState } from \"react\";\nimport type { GroupImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Group component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport function useGroupCallbackRef() {\n  return useState<GroupImperativeHandle | null>(null);\n}\n","import { useRef } from \"react\";\nimport type { GroupImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Group component.\n */\nexport function useGroupRef() {\n  return useRef<GroupImperativeHandle>(null);\n}\n","import { useContext } from \"react\";\nimport { assert } from \"../../utils/assert\";\nimport { GroupContext } from \"./GroupContext\";\n\nexport function useGroupContext() {\n  const context = useContext(GroupContext);\n  assert(\n    context,\n    \"Group Context not found; did you render a Panel or Separator outside of a Group?\"\n  );\n\n  return context;\n}\n","import type { PanelImperativeHandle } from \"../../components/panel/types\";\nimport { calculateAvailableGroupSize } from \"../dom/calculateAvailableGroupSize\";\nimport { read, update } from \"../mutableState\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\nimport { layoutNumbersEqual } from \"./layoutNumbersEqual\";\nimport { layoutsEqual } from \"./layoutsEqual\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function getImperativePanelMethods({\n  groupId,\n  panelId\n}: {\n  groupId: string;\n  panelId: string;\n}): PanelImperativeHandle {\n  const find = () => {\n    const { mountedGroups } = read();\n    for (const [\n      group,\n      { derivedPanelConstraints, layout, separatorToPanels }\n    ] of mountedGroups) {\n      if (group.id === groupId) {\n        return { derivedPanelConstraints, group, layout, separatorToPanels };\n      }\n    }\n\n    throw Error(`Group ${groupId} not found`);\n  };\n\n  const getPanelConstraints = () => {\n    const match = find().derivedPanelConstraints.find(\n      (current) => current.panelId === panelId\n    );\n    if (match !== undefined) {\n      return match;\n    }\n\n    throw Error(`Panel constraints not found for Panel ${panelId}`);\n  };\n\n  const getPanel = () => {\n    const match = find().group.panels.find((current) => current.id === panelId);\n    if (match !== undefined) {\n      return match;\n    }\n\n    throw Error(`Layout not found for Panel ${panelId}`);\n  };\n\n  const getPanelSize = () => {\n    const match = find().layout[panelId];\n    if (match !== undefined) {\n      return match;\n    }\n\n    throw Error(`Layout not found for Panel ${panelId}`);\n  };\n\n  const setPanelSize = (nextSize: number) => {\n    const prevSize = getPanelSize();\n    if (nextSize === prevSize) {\n      return;\n    }\n\n    const {\n      derivedPanelConstraints,\n      group,\n      layout: prevLayout,\n      separatorToPanels\n    } = find();\n\n    const index = group.panels.findIndex((current) => current.id === panelId);\n    const isLastPanel = index === group.panels.length - 1;\n\n    const unsafeLayout = adjustLayoutByDelta({\n      delta: isLastPanel ? prevSize - nextSize : nextSize - prevSize,\n      initialLayout: prevLayout,\n      panelConstraints: derivedPanelConstraints,\n      pivotIndices: isLastPanel ? [index - 1, index] : [index, index + 1],\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n\n    const nextLayout = validatePanelGroupLayout({\n      layout: unsafeLayout,\n      panelConstraints: derivedPanelConstraints\n    });\n    if (!layoutsEqual(prevLayout, nextLayout)) {\n      update((prevState) => ({\n        mountedGroups: new Map(prevState.mountedGroups).set(group, {\n          derivedPanelConstraints,\n          layout: nextLayout,\n          separatorToPanels\n        })\n      }));\n    }\n  };\n\n  return {\n    collapse: () => {\n      const { collapsible, collapsedSize } = getPanelConstraints();\n      const size = getPanelSize();\n\n      if (collapsible && size !== collapsedSize) {\n        setPanelSize(collapsedSize);\n      }\n    },\n    expand: () => {\n      const { collapsible, collapsedSize, minSize } = getPanelConstraints();\n      const size = getPanelSize();\n\n      if (collapsible && size === collapsedSize) {\n        setPanelSize(minSize);\n      }\n    },\n    getSize: () => {\n      const { group } = find();\n      const asPercentage = getPanelSize();\n      const { element } = getPanel();\n\n      const inPixels =\n        group.orientation === \"horizontal\"\n          ? element.offsetWidth\n          : element.offsetHeight;\n\n      return {\n        asPercentage,\n        inPixels\n      };\n    },\n    isCollapsed: () => {\n      const { collapsible, collapsedSize } = getPanelConstraints();\n      const size = getPanelSize();\n\n      return collapsible && layoutNumbersEqual(collapsedSize, size);\n    },\n    resize: (size: number | string) => {\n      const prevSize = getPanelSize();\n      if (prevSize !== size) {\n        let asPercentage;\n        switch (typeof size) {\n          case \"number\": {\n            const { group } = find();\n            const groupSize = calculateAvailableGroupSize({ group });\n            asPercentage = formatLayoutNumber((size / groupSize) * 100);\n            break;\n          }\n          case \"string\": {\n            asPercentage = parseFloat(size);\n            break;\n          }\n        }\n\n        setPanelSize(asPercentage);\n      }\n    }\n  } satisfies PanelImperativeHandle;\n}\n","import { useImperativeHandle, useRef, type Ref } from \"react\";\nimport { NOOP_FUNCTION } from \"../../constants\";\nimport { getImperativePanelMethods } from \"../../global/utils/getImperativePanelMethods\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useGroupContext } from \"../group/useGroupContext\";\nimport type { PanelImperativeHandle } from \"./types\";\n\nexport function usePanelImperativeHandle(\n  panelId: string,\n  panelRef: Ref<PanelImperativeHandle> | undefined\n) {\n  const { id: groupId } = useGroupContext();\n\n  const imperativePanelRef = useRef<PanelImperativeHandle>({\n    collapse: NOOP_FUNCTION,\n    expand: NOOP_FUNCTION,\n    getSize: () => ({\n      asPercentage: 0,\n      inPixels: 0\n    }),\n    isCollapsed: () => false,\n    resize: NOOP_FUNCTION\n  });\n\n  useImperativeHandle(panelRef, () => imperativePanelRef.current, []);\n\n  useIsomorphicLayoutEffect(() => {\n    Object.assign(\n      imperativePanelRef.current,\n      getImperativePanelMethods({ groupId, panelId })\n    );\n  });\n}\n","\"use client\";\n\nimport type { Property } from \"csstype\";\nimport { useState, type CSSProperties } from \"react\";\nimport { useId } from \"../../hooks/useId\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMergedRefs } from \"../../hooks/useMergedRefs\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { getPanelSizeCssPropertyName } from \"../group/getPanelSizeCssPropertyName\";\nimport { useGroupContext } from \"../group/useGroupContext\";\nimport { POINTER_EVENTS_CSS_PROPERTY_NAME } from \"./constants\";\nimport type { PanelProps, PanelSize } from \"./types\";\nimport { usePanelImperativeHandle } from \"./usePanelImperativeHandle\";\n\n/**\n * A Panel wraps resizable content and can be configured with min/max size constraints and collapsible behavior.\n *\n * Panel size props can be in the following formats:\n * - Percentage of the parent Group (0..100)\n * - Pixels\n * - Relative font units (em, rem)\n * - Viewport relative units (vh, vw)\n *\n * â„¹ï¸ Numeric values are assumed to be pixels.\n * Strings without explicit units are assumed to be percentages (0%..100%).\n * Percentages may also be specified as strings ending with \"%\" (e.g. \"33%\")\n * Pixels may also be specified as strings ending with the unit \"px\".\n * Other units should be specified as strings ending with their CSS property units (e.g. 1rem, 50vh)\n *\n * Panel elements always include the following attributes:\n *\n * ```html\n * <div data-panel data-testid=\"panel-id-prop\" id=\"panel-id-prop\">\n * ```\n *\n * â„¹ï¸ [Test id](https://testing-library.com/docs/queries/bytestid/) can be used to narrow selection when unit testing.\n */\nexport function Panel({\n  children,\n  className,\n  collapsedSize = \"0%\",\n  collapsible = false,\n  defaultSize,\n  elementRef,\n  id: idProp,\n  maxSize = \"100%\",\n  minSize = \"0%\",\n  onResize: onResizeUnstable,\n  panelRef,\n  style,\n  ...rest\n}: PanelProps) {\n  const idIsStable = !!idProp;\n\n  const id = useId(idProp);\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const mergedRef = useMergedRefs(setElement, elementRef);\n\n  const { id: groupId, registerPanel } = useGroupContext();\n\n  const hasOnResize = onResizeUnstable !== null;\n  const onResizeStable = useStableCallback((panelSize: PanelSize) => {\n    onResizeUnstable?.(panelSize, idProp);\n  });\n\n  // Register Panel with parent Group\n  useIsomorphicLayoutEffect(() => {\n    if (element !== null) {\n      return registerPanel({\n        element,\n        id,\n        idIsStable,\n        onResize: hasOnResize ? onResizeStable : undefined,\n        panelConstraints: {\n          collapsedSize,\n          collapsible,\n          defaultSize,\n          maxSize,\n          minSize\n        }\n      });\n    }\n  }, [\n    collapsedSize,\n    collapsible,\n    defaultSize,\n    element,\n    hasOnResize,\n    id,\n    idIsStable,\n    maxSize,\n    minSize,\n    onResizeStable,\n    registerPanel\n  ]);\n\n  usePanelImperativeHandle(id, panelRef);\n\n  const flexGrowVar = getPanelSizeCssPropertyName(groupId, id);\n\n  return (\n    <div\n      {...rest}\n      data-panel\n      data-testid={id}\n      id={id}\n      ref={mergedRef}\n      style={{\n        ...PROHIBITED_CSS_PROPERTIES,\n\n        flexBasis: 0,\n        flexGrow: `var(${flexGrowVar}, 1)`,\n        flexShrink: 1,\n\n        // Prevent Panel content from interfering with panel size\n        overflow: \"hidden\",\n\n        // Disable pointer events inside of a panel during resize\n        // This avoid edge cases like nested iframes\n        pointerEvents:\n          `var(${POINTER_EVENTS_CSS_PROPERTY_NAME})` as Property.PointerEvents\n      }}\n    >\n      <div\n        className={className}\n        style={{\n          width: \"100%\",\n          height: \"100%\",\n          ...style\n        }}\n      >\n        {children}\n      </div>\n    </div>\n  );\n}\n\nconst PROHIBITED_CSS_PROPERTIES: CSSProperties = {\n  minHeight: \"unset\",\n  maxHeight: \"unset\",\n  height: \"unset\",\n\n  minWidth: \"unset\",\n  maxWidth: \"unset\",\n  width: \"unset\",\n\n  flex: \"unset\",\n  flexBasis: \"unset\",\n  flexShrink: \"unset\",\n  flexGrow: \"unset\",\n\n  border: \"unset\",\n  borderWidth: \"unset\",\n  padding: \"unset\",\n  margin: \"unset\"\n};\n","import { useState } from \"react\";\nimport type { PanelImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Panel component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport function usePanelCallbackRef() {\n  return useState<PanelImperativeHandle | null>(null);\n}\n","import { useRef } from \"react\";\nimport type { PanelImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Panel component.\n */\nexport function usePanelRef() {\n  return useRef<PanelImperativeHandle>(null);\n}\n","import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function calculateSeparatorAriaValues({\n  layout,\n  panelConstraints,\n  panelId,\n  panelIndex\n}: {\n  layout: Layout;\n  panelConstraints: PanelConstraints[];\n  panelId: string;\n  panelIndex: number;\n}): {\n  valueControls: string | undefined;\n  valueMax: number | undefined;\n  valueMin: number | undefined;\n  valueNow: number | undefined;\n} {\n  let valueMax: number | undefined = undefined;\n  let valueMin: number | undefined = undefined;\n\n  const panelSize = layout[panelId];\n\n  const constraints = panelConstraints.find(\n    (current) => current.panelId === panelId\n  );\n  if (constraints) {\n    const maxSize = constraints.maxSize;\n    const minSize = (valueMin = constraints.collapsible\n      ? constraints.collapsedSize\n      : constraints.minSize);\n\n    const pivotIndices = [panelIndex, panelIndex + 1];\n\n    const minSizeLayout = validatePanelGroupLayout({\n      layout: adjustLayoutByDelta({\n        delta: minSize - panelSize,\n        initialLayout: layout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout: layout,\n        trigger: \"keyboard\"\n      }),\n      panelConstraints\n    });\n\n    valueMin = minSizeLayout[panelId];\n\n    const maxSizeLayout = validatePanelGroupLayout({\n      layout: adjustLayoutByDelta({\n        delta: maxSize - panelSize,\n        initialLayout: layout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout: layout,\n        trigger: \"keyboard\"\n      }),\n      panelConstraints\n    });\n\n    valueMax = maxSizeLayout[panelId];\n  }\n\n  return {\n    valueControls: panelId,\n    valueMax,\n    valueMin,\n    valueNow: panelSize\n  };\n}\n","\"use client\";\n\nimport { useState } from \"react\";\nimport { eventEmitter } from \"../../global/mutableState\";\nimport type { InteractionState } from \"../../global/types\";\nimport { calculateSeparatorAriaValues } from \"../../global/utils/calculateSeparatorAriaValues\";\nimport { useId } from \"../../hooks/useId\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMergedRefs } from \"../../hooks/useMergedRefs\";\nimport { useGroupContext } from \"../group/useGroupContext\";\nimport type { RegisteredSeparator, SeparatorProps } from \"./types\";\n\n/**\n * Separators are not _required_ but they are _recommended_ as they improve keyboard accessibility.\n *\n * Separators should be rendered as the direct child of a Group component.\n *\n * Separator elements always include the following attributes:\n *\n * ```html\n * <div data-separator data-testid=\"separator-id-prop\" id=\"separator-id-prop\" role=\"separator\">\n * ```\n *\n * â„¹ï¸ [Test id](https://testing-library.com/docs/queries/bytestid/) can be used to narrow selection when unit testing.\n *\n * â„¹ï¸ In addition to the attributes shown above, separator also renders all required [WAI-ARIA properties](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/separator_role#associated_wai-aria_roles_states_and_properties).\n */\nexport function Separator({\n  children,\n  className,\n  elementRef,\n  id: idProp,\n  style,\n  ...rest\n}: SeparatorProps) {\n  const id = useId(idProp);\n\n  const [aria, setAria] = useState<{\n    valueControls?: string | undefined;\n    valueMin?: number | undefined;\n    valueMax?: number | undefined;\n    valueNow?: number | undefined;\n  }>({});\n\n  const [dragState, setDragState] =\n    useState<InteractionState[\"state\"]>(\"inactive\");\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const mergedRef = useMergedRefs(setElement, elementRef);\n\n  const {\n    id: groupId,\n    orientation: groupOrientation,\n    registerSeparator\n  } = useGroupContext();\n\n  const orientation =\n    groupOrientation === \"horizontal\" ? \"vertical\" : \"horizontal\";\n\n  // Register Separator with parent Group\n  // Listen to global state for drag state related to this Separator\n  useIsomorphicLayoutEffect(() => {\n    if (element !== null) {\n      const separator: RegisteredSeparator = {\n        element,\n        id\n      };\n\n      const unregisterSeparator = registerSeparator(separator);\n\n      const removeInteractionStateChangeListener = eventEmitter.addListener(\n        \"interactionStateChange\",\n        (interactionState) => {\n          setDragState(\n            interactionState.state !== \"inactive\" &&\n              interactionState.hitRegions.some(\n                (hitRegion) => hitRegion.separator === separator\n              )\n              ? interactionState.state\n              : \"inactive\"\n          );\n        }\n      );\n\n      const removeMountedGroupsChangeListener = eventEmitter.addListener(\n        \"mountedGroupsChange\",\n        (mountedGroups) => {\n          mountedGroups.forEach(\n            (\n              { derivedPanelConstraints, layout, separatorToPanels },\n              mountedGroup\n            ) => {\n              if (mountedGroup.id === groupId) {\n                const panels = separatorToPanels.get(separator);\n                if (panels) {\n                  const primaryPanel = panels[0];\n                  const panelIndex = mountedGroup.panels.indexOf(primaryPanel);\n\n                  setAria(\n                    calculateSeparatorAriaValues({\n                      layout,\n                      panelConstraints: derivedPanelConstraints,\n                      panelId: primaryPanel.id,\n                      panelIndex\n                    })\n                  );\n                }\n              }\n            }\n          );\n        }\n      );\n\n      return () => {\n        removeInteractionStateChangeListener();\n        removeMountedGroupsChangeListener();\n        unregisterSeparator();\n      };\n    }\n  }, [element, groupId, id, registerSeparator]);\n\n  return (\n    <div\n      {...rest}\n      aria-controls={aria.valueControls}\n      aria-orientation={orientation}\n      aria-valuemax={aria.valueMax}\n      aria-valuemin={aria.valueMin}\n      aria-valuenow={aria.valueNow}\n      children={children}\n      className={className}\n      data-separator={dragState}\n      data-testid={id}\n      id={id}\n      ref={mergedRef}\n      role=\"separator\"\n      style={{\n        flexBasis: \"auto\",\n        ...style,\n        flexGrow: 0,\n        flexShrink: 0\n      }}\n      tabIndex={0}\n    />\n  );\n}\n"],"names":["assert","expectedCondition","message","sortByElementOffset","orientation","panelsOrSeparators","horizontalSort","verticalSort","a","b","delta","calculateAvailableGroupSize","group","panels","totalSize","panel","calculateHitRegions","groupElement","separators","sortedChildElements","child","element","hitRegions","prevPanel","prevSeparator","childElement","panelData","current","prevRect","rect","separatorData","convertEmToPixels","value","style","fontSize","convertRemToPixels","convertVhToPixels","convertVwToPixels","parseSizeAndUnit","size","numeric","sizeStyleToPixels","groupSize","panelElement","styleProp","pixels","unit","formatLayoutNumber","number","calculatePanelConstraints","panelConstraints","collapsedSize","defaultSize","minSize","maxSize","EventEmitter","#listenerMap","type","listener","listeners","data","didThrow","caughtError","clonedListeners","error","index","layoutNumbersEqual","actual","expected","minimumDelta","state","eventEmitter","read","update","partialState","prevState","constraints","prevLayout","isCollapsed","wasCollapsed","IDENTITY_FUNCTION","NOOP_FUNCTION","CURSOR_FLAG_HORIZONTAL_MIN","CURSOR_FLAG_HORIZONTAL_MAX","CURSOR_FLAG_VERTICAL_MIN","CURSOR_FLAG_VERTICAL_MAX","DEFAULT_POINTER_PRECISION","getCursorStyle","cursorFlags","groups","horizontalCount","verticalCount","horizontalMin","horizontalMax","verticalMin","verticalMax","prevStyle","styleSheet","updateCursorStyle","interactionState","cursorStyle","nextStyle","isArrayEqual","compareLayoutNumbers","validatePanelSize","collapsible","halfwayPoint","adjustLayoutByDelta","initialLayoutProp","panelConstraintsArray","pivotIndices","prevLayoutProp","trigger","initialLayout","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize","localDelta","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","unsafeSize","safeSize","pivotIndex","total","prevLayoutKeys","accumulated","layoutsEqual","id","updateActiveHitRegions","event","initialLayoutMap","mountedGroups","pointerDownAtPoint","nextMountedGroups","disableCursor","deltaAsPercentage","derivedPanelConstraints","separatorToPanels","panelIdsKey","onGroupPointerLeave","hitRegion","findSeparatorGroup","separatorElement","validatePanelGroupLayout","layout","nextLayoutTotalSize","remainingSize","getImperativeGroupMethods","groupId","find","unsafeLayout","getMountedGroup","mountedGroup","adjustLayoutForSeparator","separator","onWindowKeyDown","primaryPanel","nextSize","separatorElements","nextIndex","getDistanceBetweenPointAndRect","point","findClosetHitRegion","closestHitRegion","minDistance","cached","isCoarsePointer","findMatchingHitRegions","matchingHitRegions","_","groupData","maxDistance","match","onWindowPointerDown","didChangeFocus","onWindowPointerMove","onWindowPointerUp","calculateDefaultLayout","explicitCount","remainingPanelCount","notifyPanelOnResize","borderBoxSize","resizeObserverSize","mountGroup","isMounted","panelIds","separatorIds","resizeObserver","entries","entry","target","nextDerivedPanelConstraints","defaultLayoutUnsafe","defaultLayoutSafe","nextState","useId","stableId","dynamicId","useIdReact","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","useStableCallback","fn","ref","useRef","useCallback","args","useMergedRefs","refs","POINTER_EVENTS_CSS_PROPERTY_NAME","getPanelSizeCssPropertyName","panelId","groupIdEscaped","panelIdEscaped","GroupContext","createContext","useGroupImperativeHandle","groupRef","imperativeGroupRef","useImperativeHandle","Group","children","className","defaultLayout","disabled","elementRef","idProp","onLayoutChangeUnstable","rest","prevLayoutRef","onLayoutChangeStable","dragActive","setDragActive","useState","setElement","setLayout","setPanels","setSeparators","inMemoryLastExpandedPanelSizesRef","inMemoryLayoutsRef","mergedRef","context","useMemo","prev","unmountGroup","removeInteractionStateChangeListener","removeMountedGroupsChangeEventListener","cssVariables","propertyName","flexGrow","jsx","getStorageKey","saveGroupLayout","storage","storageKey","useDefaultLayout","defaultLayoutString","useSyncExternalStore","subscribe","onLayoutChange","useGroupCallbackRef","useGroupRef","useGroupContext","useContext","getImperativePanelMethods","getPanelConstraints","getPanel","getPanelSize","setPanelSize","isLastPanel","asPercentage","inPixels","usePanelImperativeHandle","panelRef","imperativePanelRef","Panel","onResizeUnstable","idIsStable","registerPanel","hasOnResize","onResizeStable","panelSize","flexGrowVar","PROHIBITED_CSS_PROPERTIES","usePanelCallbackRef","usePanelRef","calculateSeparatorAriaValues","panelIndex","valueMax","valueMin","Separator","aria","setAria","dragState","setDragState","groupOrientation","registerSeparator","unregisterSeparator","removeMountedGroupsChangeListener"],"mappings":"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"}